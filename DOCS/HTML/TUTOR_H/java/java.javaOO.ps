%!
%%Title: java.javaOO.html
%%DocumentFonts: NewCenturySchlbk-Roman NewCenturySchlbk-Bold NewCenturySchlbk-Italic NewCenturySchlbk-BoldItalic Courier Courier-Bold Courier-Oblique Courier-BoldOblique
%%Creator: html2ps 0.2 alpha, written by Jan Karrman, jan@tdb.uu.se
%%EndComments
save
1000 dict begin
/colorimage where {pop} {
 /colorimage {
  pop pop /Bp exch def /Gp exch def /Rp exch def
  {/Re Rp def /Gr Gp def /Bl Bp def
  0 1 Re length 1 sub {
   /i exch def Gr i Re i get 0.299 mul Gr i get 0.587 mul add
   Bl i get 0.114 mul add cvi put
  } for Gr} image
 } def
} ifelse
/D {def} def
/t {true} D
/f {false} D
/RF {/NewCenturySchlbk-Roman} D
/BF {/NewCenturySchlbk-Bold} D
/IF {/NewCenturySchlbk-Italic} D
/IB {/NewCenturySchlbk-BoldItalic} D
/FF {/Courier} D
/FB {/Courier-Bold} D
/FI {/Courier-Oblique} D
/FT {/Courier-BoldOblique} D
/F 1 D
/W {453 F div} D
/LE {651 F div} D
/PS 1 D
/HS [19 17 15 13 12 11] D
/HT [2 2 2 2 2 2] D
/MK 7 D
/NO t D
/ZL f D
/ZR f D
/Zl () D
/Zr () D
/TU f D
/AU t D
/SN 0 D
/LA {TU PM 1 eq and {W 56 F div add 0 translate}
 {70 705 translate F dup scale} ie} D
/FP 0 D
/SG [0.80000000000000004441 1 1] D
statusdict /setduplexmode known
 {statusdict begin false setduplexmode end} if
%-- End of variable part --
/ie {ifelse} D
/E {exch} D
/M {moveto} D
/S {show} D
/R {rmoveto} D
/L {lineto} D
/RL {rlineto} D
/CP {currentpoint} D
/SW {stringwidth} D
/GI {getinterval} D
/PI {putinterval} D
/U {gsave CP currentfont /FontInfo get /UnderlinePosition get
 0 E currentfont /FontMatrix get dtransform E pop add newpath M
 dup SW RL stroke grestore} D
/B {-10 3 R gsave CP newpath 2.5 0 360 arc closepath
 UI 2 mod 0 eq {stroke} {fill} ie grestore 10 -3 R} D
/NP {/PM PN SN sub 2 mod D PN SN gt TU not PM 0 eq or and {showpage} if
 0.6 setlinewidth LA /BP t D /PN PN 1 add D
 /OF currentfont D RF findfont 10 scalefont setfont
 /YO {LE neg 60 F div dup 40 gt {pop 40} if sub} D
 NO {W 2 div YO M PN ST cvs S} if
 ZL {0 YO M Zl S} if
 ZR {W YO M Zr dup stringwidth pop neg 0 R S} if
 OF setfont
 XO SZ SL get neg M /CI 0 D} D
/SF {/CS E D CS SZ SL 3 2 roll put /YI CS -1.2 mul D dup ST cvs C1 E join
 ( NF ) join /C1 E D NF /BW ( ) SW pop D} D
/NF {FL E get findfont CS scalefont setfont} D
/FS {CF MK PF {1 or} if and or /CF E D FR SL CF put CF E SF} D
/FL [RF FF BF FB IF FI IB FT] D
/reencodeISO {
dup dup findfont dup length dict begin
{ 1 index /FID ne { def }{ pop pop } ie } forall
/Encoding ISOLatin1Encoding D
currentdict end definefont
} D
/ISOLatin1Encoding [
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
/parenleft/parenright/asterisk/plus/comma/minus/period/slash
/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
/.notdef/backslash/parenleft/parenright/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve
/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut
/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar
/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
/yacute/thorn/ydieresis
] D
FL {reencodeISO D} forall

/BS {/PC E D /TX E D /fin f D /CW 0 D /LK 0 D /SC 0 D
 /RT TX D {RT ( ) search {/NW E D pop /RT E D /WH NW SW pop D CW WH add LL gt
 {TX SC LK SC sub GI PC /SC LK D /CW WH BW add D}
 {/CW CW WH add BW add D} ie
 /LK LK NW length add 1 add D} {pop exit} ie} loop
 /fin t D /LC TX length D /WH RT SW pop D CW WH add LL gt
 {TX SC LK SC sub GI PC NL RT dup () ne {PC} {pop} ie}
 {TX SC LC SC sub GI PC} ie} D

/BT {RS dup dup () ne E ( ) ne and
 {/LS LL D /LL W L1 sub XO sub D {/CI 0 D SH /BP f D fin not {NL} if
  /HM t D /LL LS D} BS} {BG {pop} {SH /BP f D} ie} ie} D
/BL {HM not {CP E pop XO E M} if} D
/NL {BL W XO sub L1 sub TB {BW add} if AT mul 2 div YA neg dup 0 lt {3 sub} if
 R F0 CF ne {F0 NF} if C1 cvx exec /C1 () D /L1 0 D /F0 CF D
 BP not {0 YB NN neg R} if /YA 0 D /YB 0 D CP /YC E D pop XO YC M YC LE neg gt
 {YI CI sub dup 0 lt BP not and {dup 0 E R CI add /CI E D} {pop} ie}
 {NP} ie /T t D} D
/RS {/TM E D /CN 0 D TM
 {dup 9 eq E 10 eq or {TM CN ( ) PI} if
  /CN CN 1 add D} forall /CN 0 D /BK HM EN and {0} {1} ie D TM
 {dup 32 ne {TM CN 3 2 roll put /CN CN 1 add D /BK 0 D}
 {pop BK 0 eq {TM CN 32 put /CN CN 1 add D} if /BK 1 D} ie}
  forall TM 0 CN GI dup dup () ne E ( ) ne and
  {dup CN 1 sub get 32 eq {/EN f D} {/EN t D} ie} if} D
/join {2 copy length E length add string dup 4 2 roll 2 index 0 3 index
 PI E length E PI} bind D
/EG {dup 0 E dup () eq {E pop} {E get} ifelse 10 ne {(\n) E join} if} D
/WR {PB {EG /PB f D} if PP {EG /PP f D} if (\n) search
 {dup () ne BP not or {TR /CI 0 D /NC 0 D NL pop WR}{pop pop WR} ie} {TR} ie} D
/TR {(\t) search {dup length /NC E NC add D SH MS 0 8 NC 8 mod sub dup
 /NC E NC add D GI SH pop TR} {dup length /NC E NC add D SH} ie
 /BP f D} D
/SH {CP E pop LE neg lt {NP} if dup SW pop L1 add /L1 E D
 C1 (\() join T not {( ) join} if E join (\)) join
 AU AF and UF or {( U ) join} if ( S ) join /C1 E D /T t D /TB EN not D} D
/BG {CP pop XO sub abs 0.01 lt} D
/ON {AR AI NN get 1 add dup AR AI 3 -1 roll put ST cvs length dup ST E (. ) PI
 ST 0 3 -1 roll 2 add GI dup SW pop neg 0 R S} D
/SP {YI E /YI E D NL /YI E D} D
/BR {BN} D
/BN {PF {WR} {BT NL} ie /HM f D} D
/AB {CH E 0 E put CH join WB} D
/NN {dup 0 lt {pop 0} if} D
/H  {1 sub /HL E D E BN /AT E D CP E pop LE neg WW add lt {NP} if
 BH SP /SL SL 1 add D HS HL get HT HL get FS} D
/EH {BN /AT 0 D AH SP /SL SL 1 sub NN D /CF 0 D SZ SL get FR SL get FS} D
/P  {E PF {WR /PP t D} {BN AE not {AH SP} if} ie /AT E D} D
/HR {BN 0 CP E pop M gsave PF {0 YI R} if W 0 RL stroke grestore /CI 0 D
 /BP f D NL} D
/AD {BN /AE t D AH SP 4 11 SF} D
/DA {BN /AE f D AH SP 0 11 SF} D
/PR {BN /AT 0 D /CF 0 D 9 PS mul 1 FS /PF t D /PB t D /NC 0 D} D
/PW {pop PR} D
/RP {PF {dup () ne {dup dup length 1 sub get 10 ne {(\n) join} if} if
 WR AH SP /CF 0 D 11 0 FS /PF f D} {BT} ie} D
/SI {/XO AI LG add NN IN mul BC NN BI mul add D /LL W XO sub D} D
/DT {BN /LG LG 1 sub D SI /LG LG 1 add D BL} D
/DD {BN SI BL} D
/DL {BN XO 0 eq {AH SP} if /LG LG 1 add D BL} D
/LD {BN LG 0 gt {/LG LG 1 sub D} if SI XO 0 eq {AH SP} if BL} D
/UL {BN XO 0 eq {AH SP} {NL} ie NR AI NN 0 put /UI UI 1 add D
 /AI AI 1 add D SI BL} D
/LU {BN /UI UI 1 sub D /AI AI 1 sub D SI XO 0 eq {AH SP} {NL} ie BL} D
/OL {BN XO 0 eq {AH SP} {NL} ie NR AI NN 1 put /AI AI 1 add D SI BL} D
/LO {BN AR AI NN 0 put /AI AI 1 sub D SI XO 0 eq {AH SP} {NL} ie BL} D
/LI {BN /BP f D /CI 0 D CP E pop LE neg lt {NP} if
 /C1 C1 NR AI 1 sub NN get 1 eq {( ON )} {( B )} ie join D BL} D
/BQ {BN AH SP /BC BC 1 add D SI BL} D
/QB {BN AH SP /BC BC 1 sub D SI BL} D
/WB {PF {WR} {BT} ie} D
/A  {WB /AF t D} D
/EA {WB /AF f D} D
/SS {SZ SL get /SL SL 1 add D} D
/I  {WB SS 4 FS} D
/BD {WB SS 2 FS} D
/TT {WB SS 1 FS} D
/KB {WB SS /CF 0 D 3 FS} D
/CT {WB SS /CF 0 D 4 FS} D
/SM {WB SS /CF 0 D 1 FS} D
/ES {WB /SL SL 1 sub NN D /CF 0 D SZ SL get FR SL get FS} D
/UN {WB /UF t D} D
/NU {WB /UF f D} D
/SB {0 1 NI {/N E D /K WS N get D /NY AY N get FC N get mul D /BV NY array D
 0 1 NY 1 sub {/TM K string D currentfile TM readhexstring pop pop BV E TM put}
 for BM N BV put} for} D
/colorimage where {pop} {
 /colorimage {
  pop pop /Bp E D /Gp E D /Rp E D
  {/Re Rp D /Gr Gp D /Bl Bp D
  0 1 Re length 1 sub {
   /i E D Gr i Re i get 0.299 mul Gr i get 0.587 mul add Bl i get 0.114 mul add
   cvi put
  } for Gr} image
 } D
} ie
/IP {BV N get /N N 1 add D} D
/II {/K E D /TY E D /XW AX K get D /YW AY K get D /IS SG IT K get get D
 /XS XW IS mul D /YS YW IS mul D YS CS sub TY 2 eq {/MB E D /MA 0 D}
 {TY 2 mod 1 eq {2 div /MA E 2 sub D /MB MA 4 add D}{/MA E D /MB 0 D} ie} ie} D
/IM {II /ty TY D /xs XS D /ys YS D /ya YA D /yb YB D /ma MA D /mb MB D /k K D
 /CI 0 D WB L1 xs add dup /L1 E D XO add W gt
 {NL /YA ma D /YB mb D /YS ys D /L1 xs D}
 {ma YA gt {/YA ma D} if mb YB gt {/YB mb D} if} ie CP E pop YS sub LE neg lt
 {NP /YA ma D /YB mb D /L1 xs D} if /BP f D ty ST cvs ( ) join k ST cvs join
 C1 E join ( DI ) join FP 2 eq FP 1 eq AF and or {( FM ) join} if /C1 E D
 /HM t D /EN f D /T TY 3 eq D} D
/DI {II /YN YW neg D /HM t D /CI 0 D /K2 IX K get D gsave CP MB sub translate
 K2 0 ge {/DP AZ K2 get D /BV BM K2 get D XS YS scale /N 0 D XW YW DP
 [XW 0 0 YN 0 YW] {IP} FC K2 get 1 eq {image} {{IP} {IP} t 3 colorimage} ie}
 {PV K2 neg 1 sub get exec} ie grestore XS 0 R} D
/FM {gsave CP MB sub translate XS neg 0 M 0 YS RL XS 0 RL 0 YS neg RL XS neg
 0 RL stroke grestore} D
/BH -35 D
/AH -28 D
/LL W D
/XO 0 D
/YI 0 D
/CI 0 D
/LG 0 D
/AI 0 D
/UI 0 D
/IN 30 D
/BI 12 D
/WW 50 D
/AR [0 0 0 0 0 0 0 0 0 0] D
/NR [0 0 0 0 0 0 0 0 0 0] D
/FR [0 0 0 0 0 0 0 0 0 0] D
/SZ [0 0 0 0 0 0 0 0 0 0] D
/SL 0 D
/CF 0 D
/BC 0 D
/YA 0 D
/YB 0 D
/F0 0 D
/N 0 D
/AT 0 D
/C1 () D
/C2 () D
/L1 0 D
/L2 0 D
/PN SN D
/MS (        ) D
/CH 1 string D
/ST 6 string D
/HM f D
/PF f D
/EN f D
/TB f D
/UF f D
/PP f D
/AE f D
/AF f D
/BP t D
/T t D
/AX [26 26 26 26 20] D
/AY [26 26 26 26 20] D
/IX [0 1 2 3 4] D
/IT [0 0 0 0 0] D
/AZ [8 8 8 8 8] D
/WS [26 26 26 26 20] D
/FC [3 3 3 3 3] D
/NI 4 D
/BM 5 array D
%%EndProlog
SB
a5a5a5a59c9c9c9c9c9c9c94949494948c8c8c8c8c8c84848487c6c6c6c6
bdbdbdbdbdb5b5b5b5b5adadadadada5a5a5a5a59c9ae7e7e7e7e7e7e7e7
e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7d6a5a5a59c9c9c9c9c9c9c9494
9494948c948c8c8c8c8484848484c6c6c6bdbdbdbdbdb5b5b5b5b5adadad
adada5a5a5a5a59c9c9ce7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7
e7e7e7e7e7e7a5a59c9c9c9c9c9c9c9494949494948c8c8f8c8c8c848487
8487c6c6bdbdbdbdbdb5b5b5b5b5adadadada5a8ada5a5a5a59a9c9ae7e7
e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7d9e7e7e7e7e7d6e7d6a59c9c9c9c9c
9c9c949494948f9494949c94948c84848484847bc6bdbdbdbdb5bdb5b5b5
b5b5a8adadadb5adada5a5a59c9c9c9ce7e7e7e7e7e7e7e7e7e7e7e7d9e7
e7e7e7e7e7e7e7e7e7e7e7e79c9c9c9c9c9c9c8f9cf7f1f1f7f7f7f7f7f7
e684848784877b7bbdbdbdbdbdb5b5a8bdfcf2f2fcfcfcfcfcfceea59c9a
9c9a9c93e7e7e7e7e7e7e7d9e7fff7f7ffffffffffffffe7e7d6e7d6e7da
9c9c9c9c9c948f8ff1f7d6f7f7f7f7f7f7f7c48484847b847b7bbdbdbdbd
b5b5a8a8f2fcd6fcfcfcfcfcfcfcd29c9c9c9c9c939ce7e7e7e7e7e7d9d9
f7ffdefffffffffffffff4e7e7e7e7e7dae79c9c9c9c8f8f87f7f7e6b1f7
f7f7f7f7f7f79c8784877b7b7b7bbdbdbdb5a8a89afcfceeb9fcfcfcfcfc
fcfcb59a9c9a9c939c93e7e7e7e7d9d9d6ffffffd9ffffffffffffffe7d6
e7d6e7dae7da9c9c9c948f72f1c46f4a87f7f7f7f7f7f7f78c84847b877b
7b7bbdbdb5b5a88cf2d281609afcfcfcfcfcfcfca59c9c9c9a949394e7e7
e7e7d9d3f7f4bdadd6ffffffffffffffe7e7e7e7d6e7dae79c9c9c8f6f8f
ce5f4a8fd6f7f7f7f7f7f7f7877b877b7b7b7b73b5b5b5a8819ad673609a
d6fcfcfcfcfcfcfc9a9c9a9c9494948ce7e7e7d9bdc0debdadc0deffffff
ffffffffd6e7d6e7e7e7e7de9c9c8f7b5e8fd28fd6f7f7f7f7f7f7a0f7e6
84847b7b7b7b737bb5b5a893749ae19ad6fcfcfcfcfcfcaefcee9c9c9c94
93948c8ce7e7d9dab1c0fbc0deffffffffffffd6ffffe7e7e7e7dae7dee7
9c948f7e4a8ff7f7f7f7f7f7f7bb5e0af7f77b7b7b7b7b7b7b73b5b5a88b
609afcfcfcfcfcfcfcc67424fcfc939c939494938c8ce7e7d9bcadc0ffff
ffffffffffdcb179ffffdae7dae7e7dae7de94948f6f4a9df7f7f7f7f1a0
5e0a0a0af7f77b7b7b7b737b7373b5b5a88160a7fcfcfcfcf2ae74242424
fcfc949394938c8c8c8ce7e7d9bdadc0fffffffff7d6b1797979ffffe7da
e7dae7e7dede949487634a8ff7f7f1b15e0a0a0a0a0a0a0a0a0a0a0a7b73
7373b5ad9a7b609afcfcf2b9742424242424242424242424948c8c8ce7e7
d6c6adc0fffff7d9b17979797979797979797979e7dedede948c87634a8f
f7c95e0a0a0a0a0a0a0a0a0a0a0a0a0a73737372adad9a7b609afccd7424
2424242424242424242424248c8c8c84e7e7d6bdadc0ffdbb17979797979
7979797979797979e7dedede948c87634a8ff7e6c4a0630a0a0a0a0a0a0a
0a0a0a0a7373736badad9a7b609afceed2ae7b2424242424242424242424
8c8c8484e7e7d6bdadc0fffff4d6bd7979797979797979797979e7ded6d6
948c87634a7ef7e6c4a79c8f5e0a0a0aa3a7635f637372736b6badad9a7b
608bfceed2bcb5a874242424b8bc7b737b8c84848484e7e7d6bdadbcffff
f4e7e7d9b1797979f7e7c6bdcededed6d6d68c8c87634a6ff7f7f7e6c4a7
a7b15e0ac4bb63636b7373736b6badad9a7b6081fcfcfceed2bcbcb97424
d2c67b7b848484848484e7e7d6c6adbdfffffffff4e7e7d9b179f4dcc6c6
d6d6d6d6d6ce8c8f876f4a5ef7f7f7f7f7d2c4a7a7b1f7ed876b736b736b
6b6bada89a816074fcfcfcfcfce1d2bcbcb9fcf89a8484848484847be7d9
d6bdadb1fffffffffffbf4e7e7d9ffffd6d6d6d6d6d6cece8c8c876b4a4a
f7f7f7f7f7f7e6c4a7bbf7f7a7726b726b6b6b6ba5a59a84605afcfcfcfc
fcfceed2bcc6fcfcbc8c848c84847b7be7e7d6cead96fffffffffffffff4
e7dcffffe7d3d6d3d6cecece8c8f876b4a37f1f7f7f7f7f7f7f7e6e6f7f7
e6736b6b6b6b6b63a5a89a84604ff2fcfcfcfcfcfcfceeeefcfcee848484
847b7b7be7d9d6cead9ff7ffffffffffffffffffffffffd6d6d6cececec6
8c8484724a378fdef7f7f7f7f7f7f7f7f7f7f7876b6b6b6b6363a5a59c8c
604f9adefcfcfcfcfcfcfcfcfcfcfc9a8484847b7b7be7e7e7d3ad9fc0de
ffffffffffffffffffffffd6d6cececec6c68487847250374a374a4a5e6f
7e7e7e7e83878f736b6b6b63635ea59a9c8c684f5a4f5a6074818b8b8b8b
959aa88c847b7b7b7b73e7d6e7d3b89f969f96adb1bdbcbcbcbcc2d6d9de
cececec6c6c68484877b635e4a4a374a4a373737374a4a636b6b6b6b6363
5e63a5a59a937b7460604f605a4f4f4f4f60607b7b84847b7b7b737be7e7
d6dac6b1adad9fad969f9f9f9fadadc6cecececec6c6c6bd8484847b7b6b
6b63635f505f5e505e505f636b6b636363635f5f9c9c9c939384847b7b73
687374687468737b847b7b7b7b7b7373e7e7e7dadad6cec6c6bdb8bdb1b8
b1b8bdc6cececec6c6c6bdbd8487847b7b7b7b73726b6b6b6b6b636b636b
6b6b6363635f5f5f9c9a9c939c93938c8c84848484847b847b7b7b7b7b7b
7b737373e7d6e7dae7dadaded3d6d6d6d6cececececececec6c6c6bdbdbd
84847b7b7b7b7b7373737373736b736b6b6b6b6363635f5f5f5e9c9c939c
9394938c8c8c8c8c84848484847b7b7b7b7b73737374e7e7dae7dae7dade
dedededed6d6d6cecececec6c6bdbdbdbdb1
a5a5a5a59c9c9c9c9c9c9c94949494948c8c8c8c8c8c84848487c6c6c6c6
bdbdbdbdbdb5b5b5b5b5adadadadada5a5a5a5a59c9ae7e7e7e7e7e7e7e7
e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7d6a5a5a59c9c9c9c9c9c9c9494
9494948c948c8c8c8c8484848484c6c6c6bdbdbdbdbdb5b5b5b5b5adadad
adada5a5a5a5a59c9c9ce7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7
e7e7e7e7e7e7a5a59c9c9c9c9c9c9c9494949494948c8c8c8c8c8c848487
8487c6c6bdbdbdbdbdbdb5b5b5b5adadadadada5a5a5a5a5a59a9c9ae7e7
e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7d6e7d6a59c9c9c9c9c
9ca79ca79c94948f94948f8c8c8c84848484847bc6bdbdbdbdb5bdbcbdbc
b5b5ada8adada8a5a5a5a5a59c9c9c9ce7e7e7e7e7e7e7e7e7e7e7e7e7d9
e7e7d9e7e7e7e7e7e7e7e7e79c9c9c9c9c9c9ce6f7f7f7f7f7f7f1f1f78f
8784848784877b7bbdbdbdbdbdb5b5eefcfcfcfcfcfcf2f2fca89aa59c9a
9c9a9c93e7e7e7e7e7e7e7fffffffffffffff7f7ffd9d6e7e7d6e7d6e7da
9c9c9c9c9c9c94c4f7f7f7f7f7f7f7d6f7ed877b877b7b847b7bbdbdbdbd
b5b5b5d2fcfcfcfcfcfcfcd6fcf89a939a9c9c9c939ce7e7e7e7e7e7e7f4
ffffffffffffffdeffffd6dad6e7e7e7dae79c9c9c9c9c9494a5f7f7f7f7
f7f7f7bbe6f7f1727b7b7b7b7b7bbdbdbdb5b5b5b5c6fcfcfcfcfcfcfcc6
eefcf28c93939c939c93e7e7e7e7e7e7e7e7ffffffffffffffdcfffff7d3
dadae7dae7da9c9c9c9c9494949cf7f7f7f7f7f7f7875e7ec4f16b72877b
7b7bbdbdb5b5b5b5b5b5fcfcfcfcfcfcfc9a748bd2f2848c9a949394e7e7
e7e7e7e7e7e7ffffffffffffffd6b1bcf4f7ced3d6e7dae79c9c9c949494
948cf7f7f7f7f7f7f7d6a0504ad68763737b7b73b5b5b5b5b5b5adadfcfc
fcfcfcfcfcd6ae6860d69a7b8c94948ce7e7e7e7e7e7e7e7ffffffffffff
ffded6b8added6c6dee7e7de9c9c94949494948cf1f7a0f7f7f7f7f7f7e6
bbd283506b73737bb5b5b5b5b5adadadf2fcaefcfcfcfcfcfceec6e19568
848c8c8ce7e7e7e7e7e7e7e7f7ffd6ffffffffffffffdcfbc2b8cededee7
9c9494949494948cf7f70a5ebbf7f7f7f7f7f7f78f4a63737373b5b5b5b5
adadadadfcfc2474c6fcfcfcfcfcfcfc9a607b8c8c8ce7e7e7e7e7e7e7e7
ffff79b1dcffffffffffffffc0adc6dedede94949494948c8c8cf7f70a0a
0a5ea0f1f7f7f7f79d4a5e727373b5b5b5adadadadadfcfc24242474aef2
fcfcfcfca760738c8c8ce7e7e7e7e7e7e7e7ffff797979b1d6f7ffffffff
c0adc6d3dede949494940a0a0a0a0a0a0a0a0a0a0a5eb1f1f7f78f375f6b
7373b5b5adad242424242424242424242474b9f2fcfc9a4f73848c8ce7e7
e7e77979797979797979797979b1d9f7ffffc09fbdd6dede9494948c0a0a
0a0a0a0a0a0a0a0a0a0a0a5ec9f78f4a5f6b7372adadadad242424242424
2424242424242474cdfc9a6073848c84e7e7e7e779797979797979797979
797979b1dbffc0adbdd6dede94948c8c0a0a0a0a0a0a0a0a0a0a0a63a0b1
e6f78f375f6b6b6badadadad24242424242424242424247baec8eefc9a4f
73848484e7e7e7e77979797979797979797979bdd6f9ffffc09fbdd6d6d6
948c948c8c7b5f63a79c0a0a0a5e8f9ca7c4e6f77e375f6b6b6badadada5
a593737bbcb524242474a8b5bcd2eefc8b4f73848484e7e7e7e7e7dabdc6
e7e7797979b1d9e7e7f4ffffbc9fbdced6d68c948c8f847b6f63c4c40a5e
a7a7a7c4e6f7f7f76f375f6b6b6badadada8a593817bd2d22474bcbcbcd2
eefcfcfc814f737b8484e7e7e7d9e7dabdc6f4f479b1e7e7e7f4ffffffff
bd9fbdced6ce8c8c8c8c87847287f1f7b1a7a7c4d2f7f7f7f7f75e4a5e63
6b6badada5a59a9c8c9af2fcb9bcbcd2e1fcfcfcfcfc745a737b847be7e7
e7e7d6e7d3d6f7ffd9e7e7f4fbffffffffffb196c6cecece8c8c8c848487
84c4f7f7a7b1c4e6f7f7f7f7f7f74a4a5f636b6ba5a5a5a5a59a9cd2fcfc
bcc8d2eefcfcfcfcfcfc5a60737b7b7be7e7e7e7e7d6e7f4ffffe7f9f4ff
ffffffffffff96adbdcecece8c8c8c84848487e6f7f7e6f1f7f7f7f7f7f7
f7f137375f636b63a5a5a5a5a59c9aeefcfceef2fcfcfcfcfcfcfcf24f4f
737b7b7be7e7e7e7e7e7d6fffffffff7fffffffffffffff79f9fbdcecec6
8c8c8484878494f7f7f7f7f7f7f7f7f7f7f7de8f374a5f636363a5a5a5a5
9a9cadfcfcfcfcfcfcfcfcfcfcfcde9a4f60737b7b7be7e7e7e7d6e7e7ff
ffffffffffffffffffffdec09fadbdc6c6c68484848484878c9c8f837e7e
7e7e6f5e4a4a3737374a5e63635fa5a5a59c9c9aa5b5a8958b8b8b8b8174
605a4f4f4f60737b7b73e7e7e7e7e7d6e7e7d9c2bcbcbcbcbdb1ad969f9f
9fadc6c6c6bd84848487847b7b7b6b504a373737374a374a374a4a506363
5f63a59c9c9a9c9c939384685a4f4f4f4f5a4f604f6060687b7b737be7e7
e7d6e7e7dadaceb8969f9f9f9f969fad9fadadb8c6c6bdbd84848484847b
7b7b6b635e5f5f5050505e505f5f5f5e63635f5f9c9c9c9c9c939493847b
7373736868687468737373737b7b7373e7e7e7e7e7dae7dad6cec6bdbdb8
b8b8b1b8bdbdbdc6bdbdbdbd8487847b7b7b7b7b7372736b6b6b6b636363
63636363635f5f5f9c9a9c939c9493948c8c8484847b7b7b7b7b7b7b7b7b
7b737373e7d6e7dae7e7dae7ded3d6d6d6cececececec6c6c6c6bdbdbdbd
84847b7b7b7b7b7b73737373736b6b6b6b6b6b6363635f5f5f5e9c9c939c
939494938c8c8c8c848484847b7b7b7b7b7b73737374e7e7dae7dae7e7da
e7dededed6d6d6cecececec6c6bdbdbdbdb1
a5a5a5a59c9c9c9c9c9c9c94949494948c8c8c8c8c8c84848487c6c6c6c6
bdbdbdbdbdb5b5b5b5b5adadadadada5a5a5a5a59c9ae7e7e7e7e7e7e7e7
e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7d6a5a5a59c9c9c9c9c9c9c9494
9494948c948c8c8c8f8487848484c6c6c6bdbdbdbdbdb5b5b5b5b5adadad
adada5a5a8a59a9c9c9ce7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7
d9e7d6e7e7e7a5a59c9c9c9c9c9c9c9494949494948c8c8c8f848784847b
8784c6c6bdbdbdbdbdb5b5b5b5b5adadadadada5a8a59a9c9c939a9ce7e7
e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7d9e7d6e7e7dad6e7a59c9c9c9c9c
f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7727b7bc6bdbdbdbdb5fcfcfcfc
fcfcfcfcfcfcfcfcfcfcfcfcfc8c939ce7e7e7e7e7e7ffffffffffffffff
ffffffffffffffffffd3dae79c9c9c9c9cf7f7f7d2d2d2d2edf7f7f7f7ed
d2d2e6f70a5e727bbdbdbdbdbdfcfcfce1e1e1e1f8fcfcfcfcf8e1e1eefc
24738c93e7e7e7e7e7fffffffbfbfbfbfffffffffffffbfbffff79c6d3da
9c9c9c9cf7f7f7c4c4c4c4f7f7f7f7f7f7f7edd2f7204a5e6b7bbdbdbdbd
fcfcfcd2d2d2d2fcfcfcfcfcfcfcf8e1fc3460738493e7e7e7e7fffffff4
f4f4f4fffffffffffffffffbff7fadc6d6da9c9c9cf7f7f7c4d2e6d2eded
e6f7f7f7f7f7f7f70a4a4a5e737bbdbdbdfcfcfcd2e1eee1f8f8eefcfcfc
fcfcfcfc246060738c94e7e7e7fffffff4fbfffbffffffffffffffffffff
79adadc6dee79c9c9c4ae69494636b6b63638c8cb1b17b847b6be64a506b
737bbdbdb560eeb5b57b84847b7badadc8c89ca59c84ee6068848c93e7e7
e7adffe7e7cececececee7e7f9f9e7e7e7d6ffadb8d6deda9c9c9c944ad2
946b6b6363637bb1b1c47ba3b18463d250847373b5b5b5b560e1b584847b
7b7b9cc8c8d294b8c8a57be1689c8c8ce7e7e7e7adfbe7cecec6c6cee7f9
f9f4e7f7f9e7cefbb8efdee79c9c9494944ad28c7b726b638484b1b1a384
84847b4ae65e8473b5b5b5b5b560e1ad938c847b9c9cc8c8b89c9c9c9c60
ee739c8ce7e7e7e7e7adfbe7dad3cecee7eff9f9f7efefefe7adffc6efde
9c9494948cf7f7c4b1d2c4d2f7f7f7f7e6ede6e6d2f74a506373b5b5b5b5
adfcfcd2c8e1d2e1fcfcfcfceef8eeeee1fc60687b8ce7e7e7e7e7fffff4
f9fbf4fbfffffffffffffffffbffadb8cee794949494f7f7d2c4c4d2c4e6
f7f7f7edd2e6f7f7f70a4a506b73b5b5b5adfcfce1d2d2e1d2eefcfcfcf8
e1eefcfcfc246068848ce7e7e7e7fffffbf4f4fbf4fffffffffffbffffff
ff79adb8d6de949494f7f7d2d2c4d2d2c4edf7f7f7f7f7f7f7f7204a4a5e
6b72b5b5adfcfce1e1d2e1e1d2f8fcfcfcfcfcfcfcfc346060738484e7e7
e7fffffbfbf4fbfbf4ffffffffffffffffff7fadadc6d6de9494944ae68c
6b6b6b6363636b727b847b727363d24a50636b72adadad60eea58484847b
7b7b848c939c948c8c7be160687b8484e7e7e7adffe7cececececececed3
dae7e7d3decefbadb8ced6de94948c8c4ad287637b846b63636b84847b73
736b5ee64a5e636badadadad60e19a7b949c847b7b84a59c9c948c8473ee
60737b84e7e7e7e7adfbd6cee7efd6c6c6d6e7efe7e7e7d6c6ffadc6ced6
948c948c8c4ae672848e6363636b7b84847b6b6b5037d2205e63adadadad
a560ee8ca5a87b7b7b849c9ca59c8484684fe134737be7e7e7e7e7adffd3
e7f6cec6c6d6e7e7e7e7d6d6b89ffb7fc6ce8c948c8c8cf7f7d2d2d2d2d2
d2f7f7f7f7e6d2edf7f7204a5063adadada5a5fcfce1e1e1e1e1e1fcfcfc
fceee1f8fcfc3460687be7e7e7e7e7fffffbfbfbfbfbfbfffffffffffbff
ffff7fadb8ce8c8c8c8cf7f7ede6e6d2d2d2e6d2edf7f7d2e6f7f70a3750
5e63adada5a5fcfcf8eeeee1e1e1eee1f8fcfce1eefcfc244f68737be7e7
e7e7fffffffffffbfbfbfffbfffffffbffffff799fb8c6ce8c8c8cf7f7f7
f7f7f7f7e6e6d2d2f7f7f7f7f7f7203750506363a5a5a5fcfcfcfcfcfcfc
eeeee1e1fcfcfcfcfcfc344f68687b7be7e7e7fffffffffffffffffffbfb
ffffffffffff7f9fb8b8cec68c8c8c4ae684b1b1b17b7b63636b638e8e8e
8e7be64a4a5e6363a5a5a560ee9cc8c8c894937b7b847ba8a8a8a89cee60
60737b7be7e7e7adffe7f9f9f9e7daceced6cef6f6f6f6e7ffadadc6c6c6
8c8c84844ad2b1a3b1b173636b8e5e8e8e8e8e847be64a505e63a5a5a5a5
60e1c8b8c8c88c7b84a873a8a8a8a89c9cee6068737be7e7e7e7adfbf9f7
f9f9deced6f6c6f6f6f6f6efe7ffadb8c6c6848484847b4ad2b1a3a37b73
5e5e63636b8e8e8e8463e64a505fa5a5a59c9c60e1c8b8b89c8c73737b7b
84a8a8a89c7bee606873e7e7e7e7e7adfbf9f7f7e7dec6c6c6c6d6f6f6f6
efceffadb8bd848484877b734ad2e6e6e6e6e6e6e6e6e6e6e6e6e6e6d2e6
0a50a59c9c9a938c60e1eeeeeeeeeeeeeeeeeeeeeeeeeeeee1ee2468e7e7
e7d6dadeadfbfffffffffffffffffffffffffffffbff79b88484877b8473
634a4a0a240a0a240a0a240a0a240a0a240a244a9c9c9a9c9c8c7b606024
3a24243a24243a24243a24243a243a60e7e7d6e7e7deceadad798e79798e
79798e79798e79798e798ead848484847b7b735e50504a504a4a504a4a4a
4a374a4a4a4a4a4a9c9c9c9c93948c7368686068606068606060604f6060
60606060e7e7e7e7dae7dec6b8b8adb8adadb8adadadad9fadadadadadad
87847b7b7b7b7b736363635e5e5e5e5e5e505050505050504a509a9c939c
9493938c7b7b7b737373737373686868686868686068d6e7dae7e7dadade
cececec6c6c6c6c6c6b8b8b8b8b8b8b8adb8
a5a5a5a59c9c9c9c9c9c9c94949494948c8c8c8c8c8c84848487c6c6c6c6
bdbdbdbdbdb5b5b5b5b5adadadadada5a5a5a5a59c9ae7e7e7e7e7e7e7e7
e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7d6a5a5a59c9c9c9c9c9c9c9494
9494948c948c8c8c8c8484848484c6c6c6bdbdbdbdbdb5b5b5b5b5adadad
adada5a5a5a5a59c9c9ce7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7
e7e7e7e7e7e7a5a59c9c9c9c9c9c9c9494949494948c8c8c8c8c8c848487
8487c6c6bdbdbdbdbdb5b5b5b5b5adadadadada5a5a5a5a5a59a9c9ae7e7
e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7d6e7d6a59c9c9c9c9c
9c9c9494949494948c8c8c8c8c8484848484847bc6bdbdbdbdb5b5b5b5b5
b5adadadadada5a5a5a5a5a59c9c9c9ce7e7e7e7e7e7e7e7e7e7e7e7e7e7
e7e7e7e7e7e7e7e7e7e7e7e79c9c9c9c8f83634a373720202424374a5e6b
8784848784877b7bbdbdbdbda8957b604f4f34343a3a4f6074849aa5a59a
9c9a9c93e7e7e7e7d9c2bdad9f9f7f7f8e8e9fadb1ced6e7e7d6e7d6e7da
9c9ca06f4a375e72a3d2f1edf1e6b1845f373763877b847b7b7bbdbdae81
604f748cb8e1f2f8f2eec89c734f4f7b9a9c9c9c939ce7e7d6bdad9fb1d3
f7fbf7fff7fff9e7bd9f9fbdd6e7e7e7dae79c9c635094c4d2e6f1f7f7f7
f7f7edf1e6d28e4a5e9ca7947b7bbdbd7b68add2e1eef2fcfcfcfcfcf8f2
eee1a86073b5bcad9493e7e7bdb8e7f4fbfff7fffffffffffff7fffbf6ad
c6e7e7e7e7da9c9c24cef1e6b184370a00001524507284b1d2f1a3f7f7f7
8c7bbdbd3ad6f2eec89c4f2400001c3a688ca5c8e1f2b8fcfcfca594e7e7
8edef7fff9e79f793b3b588eb8d3e7f9fbf7f7ffffffe7e79c9c5e84f74a
000000001500150000001537e6f18e37378ebb7bb5bd749cfc6000000000
1c001c0000001c4feef2a84f4fa8c68ce7e7b1e7ffad3b3b3b3b583b583b
3b3b589ffff7f69f9ff6dce79c9c8f37d2ed8e50240a1515150a204a6bb1
e6c4374a5063d27bb5b5a84fe1f8a8683a241c1c1c24346084c8eed24f60
687be18ce7e7d99ffbfff6b88e79585858797fadd6f9fff49fadb8cefbe7
9c94946f63f7f7f7f7f7f1e6f7f7f7f7e6c4c44a6b7b7bd2bb73b5b5b581
7bfcfcfcfcfcf2eefcfcfcfceed2d260849493e1c68ce7e7e7bdbdffffff
fffff7fffffffffffff4f4adcee7dafbdce79494948f50d2f7f7f7f7f7f7
f7f7d2c4b1b1b1248c94b1f78c73b5b5b5a868e1fcfcfcfcfcfcfcfce1d2
c8c8c83aa5adc8fca58ce7e7e7d9b8fbfffffffffffffffffbf4f9f9f98e
e7e7f9ffe7de9494948c6f72f7f7f7f7f7f7f7f7e6c4b1d2c4a3f7c4bb7b
7373b5b5adad818cfcfcfcfcfcfcfcfceed2c8e1d2b8fcd2c68c8c8ce7e7
e7e7bdd3fffffffffffffffffff4f9fbf4f7fff4dce7dede9494948c8f5f
d2f7f7f7f7f7f7f7e6c4c4d2a38e5e50506b7372adadadada873e1fcfcfc
fcfcfcfceed2d2e1b8a8736868848c84e7e7e7e7d9bdfbffffffffffffff
fff4f4fbf7f6c6b8b8d6dede94948c948c6b73f7f7f7f7f7f7f7e6d2e67b
4a6b506b7372726badadadadad848cfcfcfcfcfcfcfceee1ee9460846884
8c848c84e7e7e7e7e7cedefffffffffffffffffbffe7add6b8d6deded3d6
9494a7c4e6e663d2f7f7f7f7f7f7f7f7d250c4c4b18c73736b6badb5bcd2
eeee7be1fcfcfcfcfcfcfcfce168d2d2c8a58c8c8484e7e7e7f4ffffbdfb
fffffffffffffffffbb8f4f4f9e7deded6d68cc4e6f7f7e66b63a3d2f7f7
f7f7d2a36b4af7e6f7e6c4726b6badd2eefcfcee7b7bb8e1fcfcfcfce1b8
8460fceefceed28c8484e7f4ffffffffcec6f7fbfffffffffbf7d6adffff
fffff4d3d6ce8cd2f7f7f7f1e6a37b5f372424375073a3e6f7f7f7f1c487
6b6bade1fcfcfcf2eeb894734f3a3a4f688cb8eefcfcfcf2d29a847be7fb
fffffff7fff7e7bd9f8e8e9fb8def7fffffffff7f4d6cece8f63c4f1f7f7
f7f7f7f7f7f7f7f7f7ede6d2d2f1e6c4b1506b6ba87bd2f2fcfcfcfcfcfc
fcfcfcfcfcf8eee1e1f2eed2b9687b7bd9bdf4f7ffffffffffffffffffff
fffffffbfbf7fff4d9b8cece8c5f4a73c4e6f7f7f7f7f7f7f7f7d2d2e6e6
e6c4a75e374a6b63a573608cd2eefcfcfcfcfcfcfcfce1e1eeeeeed2bc73
4f607b7be7bdaddef4fffffffffffffffffffbfbfffffff4e7c69fadcec6
8c8c6f4a3737637ba3c4e6e6e6d2d2b18c634a372437506b6363a5a58160
4f4f7b94b8d2eeeeeee1e1c8a57b604f3a4f687b7b7be7e7bdad9f9fc6e7
f7f4fffffffbfbf9e7cead9f8e9fb8cec6c6848484847b6f504a37242424
2024242437374a506b6b6b63635ea5a5a59c938168604f3a3a3a343a3a3a
4f4f60687b847b7b7b73e7e7e7e7dabdb8ad9f8e8e8e7f8e8e8e9f9fadb8
cececec6c6c684848487847b847b7b7b7b737b73737373736b6b6b6b6363
5e63a59c9c9a9c9c9c949494938c8c8c8c8c84848484847b7b7b737be7e7
e7d6e7e7e7e7e7e7dae7e7dededed6d6d6d6cecec6c6c6bd84848484847b
7b7b7b7b7373737373736b6b6b6b636363635f5f9c9c9c9c9c9394939493
8c8c8c8c8c848484847b7b7b7b7b7373e7e7e7e7e7dae7dae7dae7dedede
ded6d6d6cecec6c6c6c6bdbd8487847b7b7b7b7b7b7373737373736b6b6b
6b6b6363635f5f5f9c9a9c939c949394938c8c8c8c8c848484847b7b7b7b
7b737373e7d6e7dae7e7dae7dae7dedededed6d6d6cececec6c6c6bdbdbd
84847b7b7b7b7b7b7373737373736b6b6b6b6b6363635f5f5f5e9c9c939c
939494938c8c8c8c8c848484847b7b7b7b7b73737374e7e7dae7dae7e7da
e7dedededed6d6d6cececec6c6bdbdbdbdb1
a5a5a59c9c9c9c9c94949494948c8c8c8c848484c6c6c6bdbdbdbdb5b5b5
b5adadadada5a5a59c9ce7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7
a5a79c9c9c9c9c94949494948c8c8c8c84848784c6bcbdbdbdbdb5b5b5b5
adadadada5a5a5a59a9ce7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7d6e7
a59c9c9c9c9c94949494948c8c8c8c8c84848487c6bdbdbdbdb5b5b5b5ad
adadada5a5a5a59c9c9ae7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7e7d6
9c9c9c835e4a3737373737374a5e7b848784847bbdbdbd95745a4f4f4f4f
4f4f5a7493a59a9c9c9ce7e7e7c2b1969f9f9f9f9f9f96b1dae7d6e7e7e7
9c8f5e4a848ed2f1f7f1f1e6a37b375f84847b7bbda87460a5a8e1f2fcf2
f2eeb8934f739c9c9394e7d9b1ade7f6fbf7fff7f7fff7da9fbde7e7dae7
9c8372d2e6d287372024508cb1c4c4a3e6e69c7bbd958ce1eee19a4f343a
68a5c8d2d2b8eeeeb593e7c2d3fbfffbd69f7f8eb8e7f9f4f4f7ffffe7da
9c9c5ef14a00000000000000006fedb1244ac47bb5bd74f2600000000000
00000081f8c83a60d28ce7e7b1f7ad3b0000000000003bbdfff98eadf4e7
9c946fa3f78c4a37242437508cd2d2374a72d273b5b581b8fca5604f3a3a
4f68a5e1e14f608ce18ce7e7bdf7ffe7ad9f8e8e9fb8e7fbfb9fadd3fbde
94949437f7f7f7f7f7f7f7f7e6d250727bc4bb73b5b5b54ffcfcfcfcfcfc
fcfceee1688c94d2c68ce7e7e79ffffffffffffffffffffbb8d3e7f4dce7
9494945e8ef7f7f7f7f7f7d2b1d28ee6c4a36b73b5adad74a8fcfcfcfcfc
fce1c8e1a8eed2b8848ce7e7e7b1f6fffffffffffffbf9fbf6fff4f7d6de
949494945ff7f7f7f7f7f7e6d2b17b5037507373adadadad73fcfcfcfcfc
fceee1c894684f688c8ce7e7e7e7bdfffffffffffffffbf9e7b89fb8dede
948c9ca57ba3f7f7f7f7f7f7e6636b7b7b73726badadb5c693b8fcfcfcfc
fcfcee7b7b938c8c8484e7e7e7e7daf7ffffffffffffffc6cedae7deded6
8cc4d2f7e650b1f7f7f7f7e68463f1e6c48f6b6badd2e1fcee68c8fcfcfc
fcee9c7bf2eed2a88484e7f4fbffffb8f9ffffffffffe7cef7fff4d9d6d6
8cd2f7f7f7c4845037374a6b8eedf7f7f1a7736bade1fcfcfcd29c684f4f
6084a8f8fcfcf2bc847be7fbfffffff4e7b89f9fadcef6fffffff7e7d6ce
8c5fc4f1f7f7f7f7f7f7f7f7f7f7f1d2a7635f6ba573d2f2fcfcfcfcfcfc
fcfcfcfcf2e1bc7b737be7bdf4f7fffffffffffffffffffff7fbe7c6bdce
8c63376384b1e6e6f1ede6e6b18e7363244a6363a57b4f7b9cc8eeeef2f8
eeeec8a88c7b3a5a7b7be7bd9fc6e7f9fffff7fffffff9f6dece8e96cec6
84847b634a373737373737373724374a5e6b6363a5a5937b604f4f4f4f4f
4f4f4f3a4f60737b7b7be7e7dac6ad9f9f9f9f9f9f9f9f8e9fadc6cec6c6
848484877b847b7b7373737373726b6b6b635e5fa59c9c9a9c9c93948c8c
8c8c848c84847b7b7373e7e7e7d6e7e7dae7dedededed6d3d6cecec6c6bd
8487847b7b7b7b737b7373736b6b6b6363635f5f9c9a9c9c9493948c8c8c
8c8484847b7b7b7b7373e7d6e7e7e7dae7dee7deded6d6d6cec6c6c6bdbd
84847b7b7b7b7b7b7373736b6b6b6363635f5f5e9c9c9c939494938c8c8c
8484847b7b7b7b737374e7e7e7dae7e7dae7deded6d6cececec6c6bdbdb1

0 11 SF
0 LE neg 20 sub M
(





)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Table Of Contents
)EH(
)0 P(
)BQ(


)UL(
)LI(
)A(Java Objects)EA(
    )UL(
    )LI(
    The Life Cycle of an Object
        )UL(
        )LI(
        )A(Creating an Object)EA(
        )LI(
        )A(Using an Object)EA(
        )LI(
        )A(Garbage Collection of Unused Objects)EA(
        )LU(
    )LI(
    )A(Creating Your Own Class)EA(
        )UL(
        )LI(
        )A(Declaring a Class)EA(
        )LI(
        Implementing a Class
 	    )UL(
            )LI(
            )A(Writing a Method)EA(
 	        )UL(
 	        )LI(
                )A(Controlling Access to a Class's Methods)EA(
 	        )LI(
                )A(Declaring a Class Method)EA(
 	        )LI(
                )A(Declaring a Final Method)EA(
 	        )LU(
            )LI(
            )A(Declaring a Member Variable)EA(
 	        )UL(
 	        )LI(
                )A(Controlling Access to a Class's Variables)EA(
 	        )LI(
                )A(Declaring a Class Variable)EA(
 	        )LI(
                )A(Declaring a Constant)EA(
 	        )LI(
                )A(Declaring a Transient Variable)EA(
 	        )LI(
                )A(Declaring a Volatile Variable)EA(
 	        )LU(
            )LU(
	)LU(
    )LI(
    )A(Interfaces)EA(
    )LU(

)LU(

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(



)0 P(
)HR(

)0 1 H(
     Java Objects
)EH(
)0 P(
)BQ(

)HR(
)BD(Author's Note:)ES( This lesson on using Java's
object features is )I(very)ES( preliminary.
It is likely that much of this lesson will change significantly
in structure, organization and content. Also, there are many
partially written sections, either missing or poor transitions,
and many missing pages. Please bear with us.
)HR(

In the lesson titled
)A(Object-Oriented Programming Concepts: A Primer)EA()A()0 4 IM()EA(
you learned the concepts behind object-oriented programming.
Now that you have an abstract understanding of object-oriented
programming, it's time to get to work and put those concepts
to practical use.
This lesson shows you how to use and abuse the object-oriented
paradigms of the Java language.
)0 P(
In this lesson, you will learn how to create and destroy objects,
how to create and subclass classes, and how to write methods.
This lesson covers everything including how to protect the innards of
an object from groups of other objects, override methods,
create class templates using abstract classes and methods,

)0 4 H(The Life Cycle of an Object)EH(
)BQ(
An object is a software module that has state and behaviour. An object's
state is contained within its variables and its behaviour is implemented
through its methods. The typical life-cycle of an object is 1\202 creation,
2\202 use, and 3\202 destruction. After an object has been created, any other
object \201that has access\202 can use its methods, or, inspect its variables.
An object remains "alive" until no other objects are using it. Once an
object has completed its useful life, you don't have to do anything--the
Java runtime system will clean it up for you!
)0 P(
Click on one of the links below for more information about each stage
of an object's life:
)UL(
)LI(
)A(Creating an Object)EA(
)LI(
)A(Using an Object)EA( including
    )UL(
    )LI(
    )A(Calling an Object's Methods)EA(
    )LI(
    )A(Referencing an Object's Variables)EA(
    )LU(
)LI(
)A(Garbage Collection of Unused Objects)EA(
)LU(
)QB(

)0 4 H()A(Creating Your Own Class)EA()EH(
)BQ(
A Java object is an )I(instance of a class)ES(.
Frequently, we say that an object's class is the object's )I(type)ES(.
The Java development environment comes with many classes that you can
use in your programs. Or you can write your own. This section shows
you how to write your own class including how to declare a class,
declare its variables, and write its methods.
)QB(


)0 4 H()A(Interfaces)EA()EH(
)BQ(
)QB(

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Creating an Object
)EH(
)0 P(
)BQ(

In Java, you create an object by creating an )I(instance of a class)ES(
or, in other words, )I(instantiating a class)ES(. To create a new object,
use Java's )SM(new)ES( operator plus a constructor for the type of
object that you want to create.
)BQ(
)PR(
new )I(Constructor\201...\202)ES(
)RP(
)QB(
Constructors are special methods provided by every Java class allowing
programmers to create and initialize objects of that type. If you are creating
your own class and want more information about how to write constructors
\201rather than how to use them which is what we cover in this section\202,
refer to )A(Missing Page)EA(.
)0 P(
Constructors have the same name as the class and, because Java supports method
name overloading, a class can have any number of constructors. The constructors
are differentiated from one another by the number and type of their arguments.
For example, each of the following methods is a constructor for the class
Rectangle in the java.awt package:
)BQ(
)PR(
public Rectangle\201\202 {
    . . .
}
public Rectangle\201int height, int width\202 {
    . . .
}
public Rectangle\201int x, int y, int height, int width\202 {
    . . .
}
)RP(
)QB(
Typically, a constructor uses its arguments to initialize the new object's 
state. So, the first constructor shown above initializes a new Rectangle
to some reasonable default, the second constructor initializes
the new Rectangle with the specified width and height, and so on.
When creating an object, you would choose the constructor whose
arguments best reflected how you wanted to initialize the new object.
)0 P(
Suppose that you were writing a drawing application and the user
drew rectangle on the screen positioned at the origin that was 100 pixels
wide by 50 pixels high. Your program would want to create an object in
memory that represented this rectangle so that the user could continue to
manipulate the rectangle.
If you were using the Rectangle class from java.awt, you would first look
at the list of constructors supported by the Rectangle class and choose the
one that best suited your needs. Since you know the dimensions and position
of the Rectangle in advance, it's probably most convenient
to use the following Rectangle constructor which allows you to initialize the
Rectangle with an x, y origin and a width and height directly from integer
values.
)BQ(
)PR(
public Rectangle\201int x, int y, int width, int height\202
)RP(
)QB(
Thus, you would create the rectangle with this Java statement:
)BQ(
)PR(
new Rectangle\2010, 0, 100, 50\202;
)RP(
)QB(
This statement creates a new object of the type Rectangle \201allocates ample
memory for it on the heap\202, does some primitive initialization \201zeros out
all of the object's variables\202, and then calls the indicated constructor
to perform more personalized initialization on the object \201initialize the
origin and dimenstions to those specified in the constructor's arguments\202.
)0 P(
The )SM(new)ES( operator returns a reference to the newly created object.
Typically, you will want to assign the return value of the )SM(new)ES(
operator to a variable so that you can use the object later. The variable
must be of the same type as the object or one of its superclasses.
)BQ(
)PR(
Rectangle rect = new Rectangle\2010, 0, 100, 50\202;
)RP(
)QB(

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Using an Object
)EH(
)0 P(
)BQ(

Once you've created an object, you will very likely want to use it for
something. Suppose, for example, that in the user of your drawing application
clicked the mouse over the rectangle and dragged it to a new location.
Your drawing application should keep pace and update the x, y position of
the memory representation of the on-screen rectangle.
)0 P(
The Rectangle class provides two equivalent ways to do this:
)OL(
)LI(
call the )SM(move\201\202)ES( method
)LI(
manipulate the object's x, y variables directly
)LO(
Option 1 is often considered "more object-oriented" and safer because you
manipulate the object's variables indirectly through its protective layer
of methods rather than twiddling directly with its variables. Manipulating
an object's variables directly is often considered error-prone; you could
potentially put the object into an inconsistent state. However, a
class would not make its variables available for direct manipulation by other
objects if it were possible for those manipulations to put the object in
an inconsistent state. So, we can assume that manipulating a Rectangle's x
and y variables directly is as safe as calling its )SM(move\201\202)ES(method.
)0 P(
A class can restrict or allow access to its instances' variables and methods
by other objects. The following two sections discuss calling methods and
manipulating variables that have been made accessible to other objects. To
learn more about specifying access to an class's methods and variables
refer to )A(Missing Page)EA(.


)0 4 H(Calling an Object's Method)EH(
)EA(
)BQ(
First, let's focus on calling the rectangle's )SM(move\201\202)ES( method.
The next section will show you how to manipulate the Rectangle's x and y
variables directly.
)0 P(

To call an object's method,)EA( simply append the method name to an object
reference with an intervening '.' \201period\202, and provide any arguments to the method
within enclosing parentheses. If the method does not require any arguments,
just use empty parentheses.
)BQ(
)PR(
object.method\201)I(argumentList)ES(\202;
   )I(or)ES(
object.method\201\202;
)RP(
)QB(
Back to the drawing application, if the user moved the rectangle named
)SM(rect)ES( to a new location, say 244, 47, the call to )SM(rect)ES('s
)SM(move\201\202)ES( method would look like this:
)BQ(
)PR(
rect.move\201244, 47\202;
)RP(
)QB(
This Java statement calls )SM(rect)ES('s )SM(move\201\202)ES( method
with two integer parameters, 244 and 47. This statement has the effect 
of moving the )SM(rect)ES( object to the x, y location 244, 47.
If you wanted to move a different rectangle, named )SM(bob)ES( for
example, to a new location you would write:
)BQ(
)PR(
bob.move\201244, 47\202;
)RP(
)QB(
As you see from these examples, method calls are directed at a specific
object; the object specified in the method call is the object that responds
to the instruction. Method calls are also called )I(messages)ES(. Just
like real-world messages, object messages must be addressed to a particular
recipient. You get different results depending on which object is the recipient
of the message. In the example above, when you send the object named )SM(rect)ES(
a )SM(move)ES( message, )SM(rect)ES( moves to the new location.
When you send the object named )SM(bob)ES( a )SM(move)ES( message,
)SM(bob)ES( moves. Very different results.
)0 P(
Like other Java statements, a method call is an expression and evaluates
to some value. The value of a method call is its return value, if it has
one. You will often wish to assign the return value of a method to a variable
or use the method call within the scope of another expression or statement. The
)SM(move\201\202)ES( method doesn't return a value \201it's declared void\202. However,
Rectangle's )SM(inside\201\202)ES( method does. The )SM(inside\201\202)ES( method
takes an x, y coordinate and returns true if that point lies within the rectangle.
So you could use the )SM(inside\201\202)ES( method to determine if some point, say
the current mouse location, was inside the rectangle and do something special
if it were.
)BQ(
)PR(
if \201rect.inside\201mouse.x, mouse.y\202\202 {	// mouse is in the rectangle
    . . .
} else {				// mouse is outside of the rectangle
    . . .
}
)RP(
)QB(
Remember that the method call is like a message to the object named. In this
case, the object named is the Rectangle named )SM(rect)ES(. Thus,
)BQ(
)PR(
rect.inside\201mouse.x, mouse.y\202
)RP(
)QB(
is asking )SM(rect)ES( if the mouse cursor location represented by
)SM(mouse.x)ES( and )SM(mouse.y)ES( is contained within it. You would
likely get a different response if you sent the same message to )SM(bob)ES(.
)0 P(
As stated )A(previously)EA(, the )I(object)ES( in
the method call )SM(object.method\201\202)ES( must be an )I(object reference)ES(.
You are not limited to using the object's name here \201if it even has one\202, you can
use an expression to determine the object to which to send a message. One common
use of an expression as object reference is just after an object is created. For
example, you can create an object and immediately thereafter call one of its methods:
)BQ(
)PR(
new Rectangle\2010, 0, 100, 50\202.equals\201anotherRect\202
)RP(
)QB(
The expression )SM(new Rectangle\2010, 0, 100, 50\202)ES( evaluates to an
object reference that refers to a Rectangle object. Thus you can use the
dot notation to then call the new rectangle's )SM(equals\201\202)ES( method
to determine if the new rectangle is equal to the one specified in
)SM(equals\201\202)ES('s argument list.
)QB(


)0 4 H(Referencing an Object's Variables)EH(
)EA(
)BQ(
You reference an object's variables in the same way that you
call its methods--simply append the variable name to an object
reference with an intervening '.' \201period\202.
)BQ(
)PR(
object.variable
)RP(
)QB(
You can use this notation to either view or modify an object's variables.
For example, we can change )SM(rect)ES('s height and width using
the following two statements:
)BQ(
)PR(
rect.height = 15;
rect.width = 37;
)RP(
)QB(
Or you can calculate the rectangle's area using these statements
)BQ(
)PR(
area = rect.height * rect.width;
)RP(
)QB(
Similar to method calls, when you reference a variable through an object,
you are referencing a particular instances variables. If )SM(bob)ES(
and )SM(rect)ES( are both rectangles of different height and widths,
this instruction
)BQ(
)PR(
area = rect.height * rect.width;
)RP(
)QB(
calculates the area of the rectangle named )SM(rect)ES( and
this instruction
)BQ(
)PR(
area = bob.height * bob.width;
)RP(
)QB(
calculates the area of the rectangle named )SM(bob)ES(.
)0 P(
As with method calls, the )I(object)ES( in )SM(object.variable)ES( must
be an )I(object reference)ES(. You are not limited to using just the object's
name here \201if it even has one\202, you can use an expression to specify the object
whose variables you want to inspect. One common use of an expression as object
reference is just after an object is created. For example, you can find out
the height of an uninitialized Rectangle with:
)BQ(
)PR(
height = new Rectangle\201\202.height;
)RP(
)QB(
)QB(

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Garbage Collection of unused objects
)EH(
)0 P(
)BQ(

Other object-oriented languages require that you keep track of all the objects
you create and that you destroy them when they are no longer needed. Writing
code to manage memory in this way is tedious and often error-prone. Java saves
you from this by allowing you to create as many objects as you want \201limited
of course to whatever your system can handle\202 but never having to destroy them.
The Java runtime environment deletes objects when it determines that they
are no longer being used. This process is known as garbage collection.
)0 P(
The Java runtime environment supports a garbage collector that periodically
frees the memory used by objects that are no longer needed.
The Java garbage collector is a mark-sweep garbage collector that scans
Java's dynamic memory areas for objects, marking those that are referenced.
After all possible paths to objects are investigated, those objects that are
not marked \201i.e. are not referenced\202 are known to be garbage and are collected.
\201A more complete description of our garbage collection algorithm might be "A
compacting, mark-sweep collector with some conservative scanning".\202
)0 P(
The garbage collector runs synchronously when the system runs out of memory, or
in response to a request from a Java program. Your Java program can ask the
garbage collector to run at any time by calling )SM(System.gc\201\202)ES(.
The garbage collector requires about 20 milliseconds to complete its task
so, your program should only run the garbage collector when there will be no
performance impact and the program anticipates an idle period long enough for
the garbage collector to finish its job.)BR(
)BD(Note:)ES( Asking the garbage collection to run does not guarantee
that your objects will be garbage collected.
)0 P(
The Java garbage collector runs asynchronously when the system is idle
on systems that allow the Java runtime to note when a thread has begun
and to interrupt another thread \201such as Windows 95\202. As soon as another
thread becomes active, the garbage collector is asked to get to a consistent
state and then terminate.

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Creating Your Own Class
)EH(
)0 P(
)BQ(

A class is a template used to create many different objects.
It is convenient to think of a class as a data type. Indeed,
objects created from the same class are often spoken of as
being of the same type.
In your Java programs you can use classes provided by other
programmers, such as the classes provided by the Java development
environment. Or you can write your own.
)0 P(
The implementation of a class is comprised of 2 components:
the class declaration and the class body.
)BQ(
)PR(
class declaration {
    . . .
    class body
    . . .
}
)RP(
)QB(

)0 4 H()A(Declaring a Class)EA()EH(
)BQ(
The class declaration declares the name of the class, its
superclass, any interfaces implemented by that class, and whether
or not the class is public, final, or abstract.
The class body contains declarations for all of the variables
and methods supported by the class.
)QB(

)0 4 H(Implementing a Class)EH(
)BQ(
The class body is the meat of any class. Within the class body, you define
all of the variables and methods for that class. This section shows you
everything you need to know about
)UL(
)LI(
)A(Writing a Method)EA(
)LI(
)A(Declaring a Member Variable)EA(
)LU(
)QB(

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Declaring a Class
)EH(
)0 P(
)BQ(

In general, a class declaration look like this:
)BQ(
)PR(
[ )I(modifiers)ES( ] class )I(ClassName)ES( [ extends )I(SuperClassName)ES( ] [ implements )I(InterfaceNames)ES( ] {
    . . .
    class body
    . . .
}
)RP(
)QB(
The items between [ and ] are optional. A class declaration defines the
following aspects of the class:
)UL(
)LI(
)I(modifiers)ES( declares whether or not the class is abstract, final or public
)LI(
)I(ClassName)ES( sets the name of the class you are declaring
)LI(
)I(SuperClassName)ES( is the name of )I(ClassName)ES('s superclass
)LI(
)I(InterfaceNames)ES( is a list of all of the interfaces implemented by
the )I(ClassName)ES(
)LU(
Of the items in a class declaration, only the )SM(class)ES( keyword
and the class name are required. The others are optional. If you do not make
an explicit declaration for the optional items, the Java compiler assumes
certain defaults.
)0 P(
The class name must be a valid Java identifier \201that is, it must be a string
of letters that begins with a Unicode letter, that contains only Unicode
letters and digits, and that is not the same as any Java keyword\202.
By convention, class names begin with a capital letter.
)0 P(
So, the most simple class declaration you can write would look like this:
)BQ(
)PR(
class ImaginaryNumber {
    . . .
}
)RP(
)QB(
This snippet of code simply declares a class named )SM(ImaginaryNumber)ES(.
When you declare a class like this, the compiler assumes the following:
)UL(
)LI(
the Object class is the super class of )SM(ImaginaryNumber)ES(
)LI(
)SM(ImaginaryNumber)ES( implements )BD(no)ES( interfaces
)LI(
)SM(ImaginaryNumber)ES( is )BD(not)ES( abstract, )BD(not)ES(
final, and is )BD(not)ES( public.
)LU(
So what does all of this mean? The following sections will shed some light
on it for you.

)0 4 H(Superclasses)EH(
)BQ(
The Object class sits at the top of the class hierarchy tree in the
Java development environment. Every class, whether written by you, by
the Java development team, or by someone else, in the Java system is a
descendent \201whether direct or indirect\202 of the Object class. The Object
class defines the basic state and behaviours that all objects must have
such as the ability to compare oneself to another object, to convert to
a string, to wait on a condition variable, to notify other objects that
a condition variable has changed, and to return the object's class. For
more information about the Object class, see )A(missing page)EA(.
)0 P(
In Java, every class must have a superclass. If you do not specify a 
superclass for your class, it is assumed to be the Object class.
To specify an object's superclass explicitly, put the keyword )SM(extends)ES(
followed by the superclass name directly after the name of the class that
you are declaring. So this class declaration
)BQ(
)PR(
class ImaginaryNumber extends Number {
    . . .
}
)RP(
)QB(
explicitly declares that the Number class is the superclass of the
)SM(ImaginaryNumber)ES( class. \201The Number class is part of the java.lang
package and is the base class for Integers, Floats and other numbers.\202
)QB(

)0 4 H(Interfaces)EH(
)BQ(
When declaring a class, you can specify which, if any, )I(interfaces)ES(
that the class implements. So, what's an interface? An interface declares
a set of methods and constants without specifying the implementation for
any of the methods. When a class claims to implement an interface, it's
claiming to provide implementations for all of the methods declared in the
interface.
)0 P(
To declare that your class implements an interface, use the keyword
)SM(implements)ES( followed by the interface. The )SM(implements)ES(
clause follows the )SM(extends)ES( clause if there is one. If there is
no )SM(extends)ES( clause, then the )SM(implements)ES( clause
follows the class name. The )SM(implements)ES( clause is optional.
)0 P(
For example, imagine an interface named Arithmetic that defines methods
named )SM(add\201\202)ES(, )SM(subtract\201\202)ES( and so on. Our ImaginaryNumber
class can declare that it implements the Arithmetic interface, thereby
guaranteeing that it provides implemenations for the )SM(add\201\202)ES(,
)SM(subtract\201\202)ES( and other methods declared by the Arithmetic
interface.
)BQ(
)PR(
class ImaginaryNumber extends Number implements Arithmetic {
    . . .
    public Number add\201Number\202 {
	. . .
    }
    public Number subtract\201Number\202 {
	. . .
    }
}
)RP(
)QB(
Note that the method signatures of the methods declared in the Arithmetic
interface and the method signatures of the methods implemented in the
ImaginaryNumber class )I(must match)ES(!
[PENDING: is the above true even for access specifiers?]
[PENDING: what are the access specifiers for methods defined in an
interface].
)QB(

)0 4 H(Abstract Classes)EH(
)BQ(
To be somewhat circular, an abstract class is a class that has at
least one abstract method in it. Well, that's not a very useful definition, is it?
What's an abstract method? An abstract method is a method that has no
implementation. The intent is to allow parent classes to leave some
methods unimplemented but still require that subclasses \201that are not
also abstract\202 provide implementations for those methods.
)0 P(
Use an abstract class when your parent class knows that all of its subclasses
will implement a certain method but each subclass will implement it
differently. In other words, there is no default implementation that
will satisfy any of the subclasses. For example, in a drawing application
Rectangle, Triangle and other GraphicObject classes all implement the
)SM(draw\201\202)ES( method, but implement it differently; there is no
appropriate default implementation for the )SM(draw\201\202)ES( method.
For more detailed information about abstract classes, see
)A(missing page)EA(.
)0 P(
To specify that your class is an abstract class, use the keyword
)SM(abstract)ES( in the "modifiers clause" that appears
before the )SM(class)ES( keyword.
)BQ(
)PR(
abstract class GraphicObject {
    . . .
}
)RP(
)QB(
The compiler will print an error message if there are no abstract methods
in a class you declare to be abstract.
)QB(

)0 4 H(Final Classes)EH(
)BQ(
You can declare a class to be final; a final class can have no subclasses.
You would a class final to guarantee that other objects and methods using
your class got exactly what they asked for. For example, the String class
in the java.lang package is a final class. The Java system must guarantee
that whenever a method or objects uses a String
they get exactly a java.lang.String and not some string that is a really
a subclass of java.lang.String. This ensures that the object in question
has no strange, inconsistent, or unpredictable properties.
)0 P(
To specify that your class is a final class, use the keyword
)SM(final)ES( in the "modifiers clause" that appears
before the )SM(class)ES( keyword.
For example, if you wanted to make the ImaginaryNumber class a final
class, its declaration would look like this:
)BQ(
)PR(
final class ImaginaryNumber extends Number implements Arithmetic {
    . . .
}
)RP(
)QB(
Note that it doesn't make sense for a class to be both final and abstract.
In other words, a class that contains declared-but-unimplemented methods
cannot be final. Attempting to declare a class as both final and abstract
results in a compile-time error.
)QB(

)0 4 H(Public Classes)EH(
)BQ(
The last modifier that you can use in a class declaration is the
)SM(public)ES( modifier. Use )SM(public)ES( to declare
that the class can be used by objects outside the current package.
By default classes can only be used within the package in which they
are declared.
)0 P(
For example, the ImaginaryNumber class should be declared public because
we want other classes and objects to have access to this class. Thus
the class declaration for the ImaginaryNumber class now looks like this:
)BQ(
)PR(
public final class ImaginaryNumber extends Number implements Arithmetic {
    . . .
}
)RP(
)QB(
By convention, when you use the )SM(public)ES( keyword in a class
declaration, you should make it the very first item in a class declaration
preceding either )SM(final)ES( or )SM(abstract)ES( if one of them
is also being used.
)QB(

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Writing a Method
)EH(
)0 P(
)BQ(

As you know, objects have behaviour and that behaviour is implemented
by its methods. Other objects can ask an object to do something by
invoking its methods. This section tells you everything you need to know
to write methods for your Java classes. For more information about
how to call methods see )A(Missing Page)EA(.
)0 P(
At minimum a method declaration has a return type indicating the data type
of the value returned by the method, a name, and a method body that contains
the Java instructions that implement the method:
)BQ(
)PR(
)I(return_type)ES( )I(method_name\201\202)ES( {
    . . .
    )I(method body)ES(
    . . .
}
)RP(
)QB(
For example, the following is a method declaration of a simple method
that returns a boolean value \201true or false\202 indicating whether or not
something is empty.
)BQ(
)PR(
boolean isEmpty\201\202 {
    . . .
}
)RP(
)QB(
Alone this method has no meaning--is )I(what)ES( empty?
This is because this particular method declaration is not associated
with any class. It is the combination of a class and a method that
gives meaning to a method. In Java, methods are associated with classes
or objects and operate on the class or object with which they are
associated. The results you get from the )SM(isEmpty\201\202)ES( method
only have meaning if the method is associated with a stack object, or
an array object, or some other type of object that can contain objects
or data.
)0 P(
In Java every method )I(must)ES( be within a class declaration.
An earlier section, )A(Declaring a Class)EA(,
showed you the general outline of a class declaration:
)BQ(
)PR(
class declaration {
    . . .
    class body
    . . .
}
)RP(
)QB(
Within the class you define all the variables and methods supported
by that class. This page focuses on how to declare and implement methods for
a class. The )A(next page)EA( shows you how
to declare your class's methods.
)0 P(
You declare all of the methods that are a member of the class within
the class body. Typically, you declare a class's methods after
you declare its variables, although this is not required.
)BQ(
)PR(
class declaration {
    . . .
    )I(member variable declarations)ES(
    . . .
    )I(method declarations)ES(
    . . .
}
)RP(
)QB(
Let's put the )SM(isEmpty\201\202)ES( method in an appropriate class:
)BQ(
)PR(
class stack {
    . . .
    boolean isEmpty\201\202 {
        . . .
    }
}
)RP(
)QB(
Now, we can say that the )SM(isEmpty\201\202)ES( methods returns true
when the stack is empty and returns false otherwise.
)0 P(
The method declaration shown above is a very basic method declaration.
Methods have many other attributes such as parameters, access control,
and so on.

)0 4 H(Returning a Value from a Method)EH(
)BQ(
Java requires that a method declare the data type of the value that
it returns. If a method returns no value, it can be declared to return
)SM(void)ES(.
)0 P(
There are two major categories
of data types in the Java language: simple types and complex types.
Simple data types are comprised of a single value and include
integer numbers, floating point numbers, boolean values, and characters
\201a single character, that is\202. Complex types are comprised of multiple
or complex values and, sometimes, the operations that can be performed
on those values. Complex types include classes, interfaces, and arrays.
)0 P(
Methods can return either values of simple data types or of complex data
types. For example, this method returns a simple data type, a boolean value:
)BQ(
)PR(
class Stack {
    static final int STACK_EMPTY = -1;
    Object stackelements[];
    int topelement = STACK_EMPTY;
    . . .
    boolean isEmpty\201\202 {
	if \201topelement == STACK_EMPTY\202
            return true;
	else
            return false;
    }
}
)RP(
)QB(
The )SM(return)ES( operator returns the value and must be the last
statement in the method. Any method that is )I(not)ES( declared )SM(void)ES(
must contain a )SM(return)ES( statement.
The )SM(return)ES( operator places the indicated value on the stack where the
calling method can then retrieve it.
)0 P(
The following method returns a complex data type: an object.
)BQ(
)PR(
class Stack {
    static final int STACK_EMPTY = -1;
    Object stackelements[];
    int topelement = STACK_EMPTY;
    . . .
    Object pop\201\202 {
	if \201topelement == STACK_EMPTY\202
	    return null;
	else {
	    return stackelements[topelement--];
	}
    }
}
)RP(
)QB(
The data type of the value returned by the )SM(return)ES( statement
must match the data type that the method claims to return. For example,
you can't return an Object from a method declared to return an integer.
When returning an object the object must either derive from, or be the
class indicated.
If your method returns an interface type, the object returned must
implement that interface.

)QB(

)0 4 H(A Method's Name)EH(
)BQ(
A method name can be any legal Java identifier.
There are two special cases to consider in regards to Java method names.
)0 P(
)OL(
)LI(
Java supports method name overloading so multiple methods can
share the same name. For example, suppose you were writing a class that
can render various types of data to its drawing area. You would need to
write a method that knew how to render each data type. In other languages,
you would have to think of a new name for each method: )SM(drawString\201\202)ES(,
)SM(drawInteger\201\202)ES(, )SM(drawFloat\201\202)ES(, and so on. In Java, you
can use the same name for all of the drawing methods but pass in a different
type of parameter to each method. So, in your data rendering class,
you can declare three methods named )SM(draw\201\202)ES( each of which
takes a different type parameter:
)BQ(
)PR(
class DataRenderer {
    void draw\201String s\202 {
        . . .
    }
    void draw\201int i\202 {
        . . .
    }
    void draw\201float f\202 {
        . . .
    }
}
)RP(
)QB(
)HR(
)BD(Note:)ES( The information within the \201 and \202 in the
method declaration are parameters to the method. Parameters are covered
later in this section in )A(Missing Page)EA(.
)HR(
The methods are differentiated by the compiler by the number and type of
the arguments passed into the method. Thus, )SM(draw\201String s\202)ES(
and )SM(draw\201int i\202)ES( are distinct and unique; and, )SM(draw\201String s\202)ES(
and )SM(draw\201String t\202)ES( are identical and will result in a compiler error.
Overloaded methods must return the same data type.
)LI(
Any method whose name is the same as the name of the class in which the
method is defined is a constructor method and has a special duty to perform.
Constructors are used to create and initialize a new object of the class
type. For more information about how to create an object, see
)A(Creating an Object)EA(.
For more information about how to write a constructor, see
)A(Writing a Constructor Method)EA(.
)LO(
)QB(

)0 4 H()A(A Method's Body)EA()EH(
)BQ(
The method body is where all of the action of a method takes place.
The method body contains all of the legal Java instructions that
implement the method.
)UL(
)LI(
Passing Information into and out of Methods
\201pass by reference\202
)LI(
Using this & super
)LU(
)QB(

)0 4 H(Other Method Stuff)EH(
)BQ(
)UL(
)LI(
)A(Throwing Exceptions within a Method)EA(
)LI(
)A(Writing a Constructor Method)EA(
)LI(
)A(Writing a finalize\201\202 Method)EA(
)LI(
)A(Controlling Access to a Class's Methods)EA(
)LI(
)A(Writing a Class Method)EA(
)LI(
)A(Writing Native Methods)EA(
)LI(
)A(Writing Synchronized Methods)EA(

)LI(
)A(Declaring a Final Method)EA(
)LI(
)A(Writing Abstract Methods)EA(
)LU(
)QB(

)0 4 H(Summary)EH(
)BQ(
)BQ(
)PR(
[)I(access_specifier)ES(] [static] [abstract] [final] [native] [synchronized] return_value )I(methodname)ES( \201[)I(paramlist)ES(]\202 [throws )I(exceptionsList)ES(]
)RP(
)QB(
)QB(

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Controlling Access to a Class's Methods
)EH(
)0 P(
)BQ(

The Java language supports five distinct access levels for
methods: private, private protected, protected, public, and,
if left unspecified, "friendly". The following chart shows
the access level permitted by each specifier.
)BQ(
)PR(
				sub-	pack-
Specifier		class	class	age	world
-----------------------------------------------------
private			X
private protected	X	X
protected		X	X*	X
public			X	X	X	X

friendly		X	 	X
)RP(
)QB(
The first column indicates whether or not the class itself can call
the method defined by the access specifier. The second
column indicates whether or not subclasses of the class \201regardless of
which package they are in\202 can call the method. The
third column indicates whether or not classes in the same package
\201regardless of their parentage\202 as the class can call the
method. And finally, the fourth column indicates that all
classes can call the method.
)0 P(
You'll note that the protected access specifier/sub-class intersection
has an '*' -- this indicates that this particular access case
has a special caveat which is discussed in detail )A(below)EA(.
)0 P(
Let's look at each access level in more detail.

)0 4 H(Private)EH(
)BQ(
Let's begin with the most restrictive access level--private.
Only the class in which a private method is defined can call that
method. To declare a private method, use the keyword )SM(private)ES(.
For example, the following class defines one private method within it:
)BQ(
)PR(
class Alpha {
    private void iamprivate\201\202 {
	System.out.println\201"iamprivate"\202;
    }
}
)RP(
)QB(
Objects of type Alpha can call the )SM(iamprivate\201\202)ES( method,
but objects of other types cannot. For example, the following class,
regardless of which package it is in or its parentage, cannot call
the )SM(iamprivate\201\202)ES( method within the Alpha class.
)BQ(
)PR(
class Beta {
    void accessMethod\201\202 {
        Alpha a = new Alpha\201\202;
        a.iamprivate\201\202;		// illegal
    }
}
)RP(
)QB(
You can tell when one of your classes is attempting to access a method to
which it does not have access--the compiler will print an error message similar
to the following and refuse to compile your program.
)BQ(
)PR(
Beta.java:12: No method matching iamprivate\201\202 found in class Alpha.
        a.iamprivate\201\202;		// illegal
1 error
)RP(
)QB(
)QB(

)0 4 H(Private Protected)EH(
)BQ(
The next most restrictive access specified is private protected. This
access level includes the same access level as private plus allows
any of the class's subclasses to call the method.
To declare a private protected method, use the keywords )SM(private protected)ES(.
For example, the following class defines one private protected method within it:
)BQ(
)PR(
class Alpha {
    private protected void iamprivateprotected\201\202 {
	System.out.println\201"iamprivateprotected"\202;
    }
}
)RP(
)QB(
Objects of type Alpha can call the )SM(iamprivateprotected\201\202)ES(
method. In addition, subclasses of Alpha also have access to
)SM(iamprivateprotected\201\202)ES(. For instance, this subclass of
Alpha can call the )SM(iamprivateprotected\201\202)ES( method of
another Alpha object.
)BQ(
)PR(
class Beta extends Alpha {
    void modifyVariable\201Alpha a\202 {
        a.iamprivateprotected\201\202;	// legal
    }
}
)RP(
)QB(
The output from this method call will be the string
)BQ(
)PR(
iamprivateprotected
)RP(
)QB(
)QB(

)0 4 H(Protected)EH(
)BQ(
The next access level specifier is protected which allows the class itself,
subclasses \201with a caveat\202, and all classes in the same package to call
the method.
To declare a protected method, use the keyword )SM(protected)ES(.
For example, take this version of the Alpha class which
is now declared to be within a package named "Greek" and which has a
single protected method declared within it.
)BQ(
)PR(
package Greek;

class Alpha {
    protected void iamprotected\201\202 {
	System.out.println\201"iamprotected"\202;
    }
}
)RP(
)QB(
Now, suppose that the class, Beta, was also declared to be a member of
the Greek package. The Beta class can legally call the )SM(iamprotected\201\202)ES(
method declared within the Alpha class.
)BQ(
)PR(
package Greek;

class Beta {
    void accessMethod\201\202 {
        Alpha a = new Alpha\201\202;
        a.iamprotected\201\202;	// legal
    }
}
)RP(
)QB(
The output from this method call will be the string
)BQ(
)PR(
iamprotected
)RP(
)QB(

That's pretty straightforward.)EA( Now, let's investigate how subclasses of
Alpha can access protected methods.
)0 P(
Let's introduce a new class, Gamma, that
derives from Alpha but lives in a different package. The Gamma class can
access the )SM(iamprotected\201\202)ES( method, but only on objects of type
Gamma or its subclasses. For example, the )SM(accessMethod\201\202)ES(
of the following class attempts to access the )SM(iamprotected\201\202)ES(
method on an object of type ProtectedAlpha, which is illegal, and on an object
of type Gamma, which is legal.
)BQ(
)PR(
class Gamma {
    void accessMethod\201ProtectedAlpha a\202 {
        a.iamprotected = 10;		// illegal
        this.iamprotected = 10;		// illegal
    }
}
)RP(
)QB(
If a class is both a subclass of and in the same package as the class
with the protected variable, then the class has access to the protected
method \201its package status takes precedence over its subclass status\202.
)QB(

)0 4 H(Public)EH(
)BQ(
Now for the easiest access specifier--public. To declare a public method,
use the keyword )SM(public)ES(. For example,
)BQ(
)PR(
class Alpha {
    public void iampublic\201\202 {
	System.out.println\201"iampublic"\202;
    }
}
)RP(
)QB(
Any class, in any package, can call a class's public methods.
For example, this version of the Beta class
)BQ(
)PR(
class Beta {
    void accessMethod\201\202 {
	Alpha a = new Alpha\201\202;
        a.iampublic\201\202;			// legal
    }
}
)RP(
)QB(
can legally call the )SM(iampublic\201\202)ES( method
in the Alpha class.
)QB(

)0 4 H(Friendly)EH(
)BQ(
And finally, the last access level is what you get if you don't
explicitly set a method's access level to one of the previous levels.
This access level is known as "friendly".
For example, this version of the Alpha class declares a single
friendly method and lives within the Greek package.
)BQ(
)PR(
package Greek;

class Alpha {
    void iamfriendly\201\202 {
	System.out.println\201"iamfriendly"\202;
    }
}
)RP(
)QB(
The Alpha class can call the )SM(iamfriendly\201\202)ES( method.
In addition, all the classes declared within the same package as
Alpha can also call )SM(iamfriendly\201\202)ES(.
For example, suppose that both Alpha and Beta were declared
as part of the Greek package, then this Beta class
)BQ(
)PR(
package Greek;

class Beta {
    void accessMethod\201\202 {
        Alpha a = new Alpha\201\202;
        a.iamprotected\201\202;	// legal
    }
}
)RP(
)QB(
could legally call )SM(iamfriendly\201\202)ES(.
)QB(

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Writing a Class Method
)EH(
)0 P(
)BQ(

By default, when you declare a method within a class that method
is an )I(instance method)ES(. All instances of the class share
the same implementation of an instance method. However, the instance
method operates on the instance variables that are particular to
that instance. For example, the class defined below has one instance
variable, an integer named x.
)BQ(
)PR(
class AnIntegerNamedX {
    int x;
}
)RP(
)QB(
Every time you instantiate AnIntegerNamedX, you create an instance
of AnIntegerNamedX and each instance of AnIntegerNamedX gets its own
copy of )SM(x)ES(. To access a particular )SM(x)ES(, you
must access it through the object with which it is associated \201either
directly, if you have access, or through the instance's methods\202.
There is no other way to access )SM(x)ES( except through the
instance.
)0 P(
Now, let's make )SM(x)ES( private, and create two public methods
within AnIntegerNamedX which allows other objects to set and query
the value of )SM(x)ES(.
)BQ(
)PR(
class AnIntegerNamedX {
    private int x;
    public int x\201\202 {
	return x;
    }
    public void setX\201int newX\202 {
	x = newX;
    }
}
)RP(
)QB(
Note that these two methods refer directly to )SM(x)ES( without
using the dot notation. Assuming that there are no other variables
within this scope named )SM(x)ES(, an object's instance methods
automatically refer to the object's instance variables by name.
)0 P(
Now the following code snippet creates two different instaces of type
AnIntegerNamedX, sets their )SM(x)ES( values to different values
using the new )SM(setX\201\202)ES( method, and then prints
out the values.)EA(
)BQ(
)PR(
. . .
AnIntegerNamedX myX = new AnIntegerNamedX\201\202;
AnIntegerNamedX anotherX = new AnIntegerNamedX\201\202;
myX.setX\2011\202;
anotherX.setX\2012\202;
System.out.println\201"myX.x = " + myX.x\201\202\202;
System.out.println\201"anotherX.x = " + anotherX.x\201\202\202;
. . .
)RP(
)QB(
The output produced by this code snippet is
)BQ(
)PR(
myX.x = 1
anotherX.x = 2
)RP(
)QB(
illustrating that each instance of the class AnIntegerNamedX has its
own copy of the instance variable )SM(x)ES(, and that an instance's
instance methods operate on that instance's instance variables.
)0 P(
When declaring a method, you can specify that method to
be a )I(class method)ES( rather than an instance method. As you know,
the system creates a single copy of a class variable the first time it
encounters the class in which the variable is defined. All instances
of that class share the same class variable. Class methods operate
on class variables.
)0 P(
To specify that a method is a class method, use the keyword
)SM(static)ES(. For example, let's change the AnIntegerNamedX
class such that its )SM(x)ES( variable is now a class variable
and that it's )SM(x\201\202)ES( and )SM(setX\201\202)ES( methods are
now class methods:
)BQ(
)PR(
class AnIntegerNamedX {
    static private int x;
    static public int x\201\202 {
	return x;
    }
    static public void setX\201int newX\202 {
	x = newX;
    }
}
)RP(
)QB(
Now the exact same code snippet )A(from before)EA( that
creates two instances of AnIntegerNamedX, sets their )SM(x)ES( values,
and then prints the )SM(x)ES( values produces this, different, output.
)BQ(
)PR(
myX.x = 2
anotherX.x = 2
)RP(
)QB(
That's because now that )SM(x)ES( is a class variable there is only
one copy of the variable and it is shared by all instances of AnIntegerNamedX
including )SM(myX)ES( and )SM(anotherX)ES(. And the class methods
)SM(x\201\202)ES( and )SM(setX\201\202)ES( refer to the same variable--the class
variable )SM(x)ES(.

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Declaring a Final Method
)EH(
)0 P(
)BQ(

You can use the )SM(final)ES( keyword in a method declaration to
indicate to the compiler that the method cannot be overridden by
subclasses.
)0 P(
You will want to make some methods final to prevent subclasses from
overriding that method particularly if the method has an implementation
that cannot and should not be changed and is critical to the consistent
state of the object. For example,

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Declaring a Member Variable
)EH(
)0 P(
)BQ(

[PENDING: fix intro to this page]
In Java, there are two different kinds of variables: variables that are
associated with an object or class \201called )I(member variables)ES(\202 and
those that are not associated with an object or class but are used locally
within methods and other code blocks \201local variables, parameters, etc.\202.
This page talks about member variables. For more information regarding
local and other variables, see )A(missing page)EA(.
)0 P(
You define all member variables within the body of the class. The following
is a general description of all member variable declarations in Java.
)BQ(
)PR(
[)I(accessSpecifier)ES(] [static] [final] [transient] [volatile] )I(type)ES( )I(variablename)ES(
)RP(
)QB(
There are two different types of member variables: class variables and
instance variables. A class variable occurs once per class regardless of
the number of instances created of that class. The system allocates
memory for class variables the first time it encounters the class.
An instance variable occurs once per instance of a class; that is,
every time you create a new instance of the class, the system allocates
memory for all of the class's instance variables.
)0 P(
An earlier section, )A(Declaring a Class)EA(,
showed you the general outline of a class declaration:
)BQ(
)PR(
class declaration {
    . . .
    class body
    . . .
}
)RP(
)QB(
Within the class you define all the variables and methods supported
by that class. This page focuses on how to declare variables for
a class. The )A(next page)EA( shows you how
to declare and implement your class's methods.
)0 P(
You declare all of the variables that are a member of the class within
the class body. Typically, you declare a class's variables before
you declare its methods, although this is not required.
)BQ(
)PR(
class declaration {
    . . .
    )I(member variable declarations)ES(
    . . .
    )I(method declarations)ES(
    . . .
}
)RP(
)QB(
)BD(Note:)ES( To declare variables that are a member of a
class, the declarations must be within the class body, but )BD(not)ES(
within the body of a method. Variables declared within the body of a method
are local to that method.
)0 P(
At minimum, a member variable declaration has two components: the type
of the variable and its name. For example, the following code snippet
declares an integer variable named )SM(anInteger)ES( for the class
)SM(IntegerClass)ES(.
)BQ(
)PR(
class IntegerClass {
    int anInteger;
}
)RP(
)QB(
When you declare a variable like this, you declare an )I(instance variable)ES(.
[PENDING: More more more]. For information about declaring class variables, see
)A(somewhere else)EA(


)0 4 H(A Variable's Type)EH(
)EA(
)BQ(
Every variable in a Java program must have a type. A variable's type
determines the values that the variable can have and the operations
that can be performed on the variable. There are two major categories
of data types in the Java language: simple types and complex types.
Simple data types are comprised of a single value and include
integer numbers, floating point numbers, boolean values, and characters
\201a single character, that is\202. Complex types are comprised of multiple
or complex values and, sometimes, the operations that can be performed
on those values. Complex types include classes, interfaces, and arrays.
)0 P(
The following table lists all of the simple data types supported
by the Java language, the keyword that you use to declare a variable
of that type, and the size of the variable.
)BQ(
)PR(
Keyword		Size	Description
----------------------------
\201integer types\202
byte		8-bit	Byte-length integer
short		16-bit	Short integer
int		32-bit	Integer
long		64-bit	Long integer

\201floating-point types\202
float		32-bit	single-precision floating point
double		64-bit	double-precision floating point

\201other types\202
char		16-bit	a single Unicode character
boolean		N/A	a Boolean
)RP(
)QB(
)0 P(
[PENDING: Say something intelligent about complex data types.]
)QB(

)0 4 H(A Variable's Name)EH(
)BQ(
[PENDING: More here]
)QB(

)0 4 H(Other Variable Declaration Components)EH(
)BQ(
Besides type and name, there are several other variable attributes
that you can specify when declaring a variable. These include such
attributes as whether other objects can access the variable,
whether or not the variable is a class or instance
variable and whether or not the variable is a constant.
)0 P(
Follow these links to find more information about
)UL(
)LI(
)A(Controlling Access to a Class's Variables)EA(
)LI(
)A(Declaring a Class Variable)EA( [PENDING: this might be too hidden]
)LI(
)A(Declaring a Constant)EA(
)LI(
)A(Declaring a Transient Variable)EA(
)LI(
)A(Declaring a Volatile Variable)EA(
)LU(
)QB(

)0 4 H(Summary)EH(
)BQ(
In summary, a member variable declaration looks like this:
)BQ(
)PR(
[)I(accessSpecifier)ES(] [static] [final] [transient] [volatile] )I(type)ES( )I(variablename)ES(
)RP(
)QB(
The items between [ and ] are optional. Italic items are to be replaced
by keywords or names.
)0 P(
A variable declaration defines the following aspects of the variable: 
)UL(
)LI(
)I(accessSpecifier)ES( defines which other classes have access to
the variable
)LI(
)SM(static)ES( indicates that the variable is a class member variable
as opposed to an instance member variable
)LI(
)SM(final)ES( indicates that the variable is a constant
)LI(
)SM(transient)ES( variables are not part of the object's persistent state
)LI(
)SM(volatile)ES( means that the variable is modified asynchronously
)LU(
)QB(
)QB(

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Controlling Access to a Class's Variables
)EH(
)0 P(
)BQ(

The Java language supports five distinct access levels for
variables: private, private protected, protected, public, and,
if left unspecified, "friendly". The following chart shows
the access level permitted by each specifier.
)BQ(
)PR(
				sub-	pack-
Specifier		class	class	age	world
-----------------------------------------------------
private			X
private protected	X	X
protected		X	X*	X
public			X	X	X	X

friendly		X	 	X
)RP(
)QB(
The first column indicates whether or not the class itself has access
to the variable defined by the access specifier. The second
column indicates whether or not subclasses of the class \201regardless of
which package they are in\202 have access to the variable. The
third column indicates whether or not classes in the same package
\201regardless of their parentage\202 as the class have access to the
variable. And finally, the fourth column indicates that all
classes have access to the variable.
)0 P(
You'll note that the protected access specifier/sub-class intersection
has an '*' -- this indicates that this particular access case
has a special caveat which is discussed in detail )A(below)EA(.
)0 P(
Let's look at each access level in more detail.

)0 4 H(Private)EH(
)BQ(
Let's begin with the most restrictive access level--private.
A private variable is only accessible to the class in which
it is defined.
To declare a private variable, use the keyword )SM(private)ES(.
For example, the following class defines one private variable within it:
)BQ(
)PR(
class Alpha {
    private int iamprivate;
}
)RP(
)QB(
Objects of type Alpha can inspect or modify the )SM(iamprivate)ES( variable,
but objects of other types cannot. For example, the following class,
regardless of which package it is in or its parentage, cannot access the )SM(iamprivate)ES(
variable within the Alpha class.
)BQ(
)PR(
class Beta {
    void accessMethod\201\202 {
        Alpha a = new Alpha\201\202;
        a.iamprivate = 10;	// illegal
    }
}
)RP(
)QB(
You can tell when one of your classes is attempting to access a variable to
which it does not have access--the compiler will print an error message similar
to the following and refuse to compile your program.
)BQ(
)PR(
Beta.java:9: Variable iamprivate in class Alpha not accessible from class Beta.
        a.iamprivate = 10;     // illegal
         ^
1 error
)RP(
)QB(
)QB(

)0 4 H(Private Protected)EH(
)BQ(
The next most restrictive access specified is private protected. This
access level includes the same access level as private plus allows
any of the class's subclasses to access the variable.
To declare a private protected variable, use the keywords )SM(private protected)ES(.
For example, the following class defines one one private protected variable within it:
)BQ(
)PR(
class Alpha {
    private protected int iamprivateprotected;
}
)RP(
)QB(
Objects of type Alpha can inspect or modify the )SM(iamprivateprotected)ES(
variable. In addition, subclasses of Alpha also have access to
)SM(iamprivateprotected)ES(. For instance, this subclass of
Alpha can assign its )SM(iamprivateprotected)ES( variable to
that of another Alpha object.
)BQ(
)PR(
class Beta extends Alpha {
    void modifyVariable\201Alpha a\202 {
        a.iamprivateprotected = this.iamprivateprotected;	// legal
    }
}
)RP(
)QB(
)QB(

)0 4 H(Protected)EH(
)BQ(
The next access level specifier is protected which allows the class itself,
subclasses \201with a caveat\202, and all classes in the same package to access
the variable.
To declare a protected variable, use the keyword )SM(protected)ES(.
For example, take this version of the Alpha class which
is now declared to be within a package named "Greek" and which has a
single protected variable declared within it.
)BQ(
)PR(
package Greek;

class Alpha {
    protected int iamprotected;
}
)RP(
)QB(
Now, suppose that the class, Beta, was also declared to be a member of
the Greek package. The Beta class can legally access the )SM(iamprotected)ES(
variable declared within the Alpha class.
)BQ(
)PR(
package Greek;

class Beta {
    void accessMethod\201\202 {
        Alpha a = new Alpha\201\202;
        a.iamprotected = 10;	// legal
    }
}
)RP(
)QB(

That's pretty straightforward.)EA( Now, let's investigate how subclasses of
Alpha can access protected variables.
)0 P(
Let's introduce a new class, Gamma, that
derives from Alpha but lives in a different package. The Gamma class can
access the )SM(iamprotected)ES( variable, but only on objects of type
Gamma or its subclasses. For example, the )SM(accessMethod\201\202)ES(
of the following class attempts to access the )SM(iamprotected)ES(
variable on an object of type ProtectedAlpha, which is illegal, and on an object
of type Gamma, which is legal.
)BQ(
)PR(
class Gamma {
    void accessMethod\201ProtectedAlpha a\202 {
        a.iamprotected = 10;    //illegal
        this.iamprotected = 10;
    }
}
)RP(
)QB(
If a class is both a subclass of and in the same package as the class
with the protected variable, then the class has access to the protected
variable \201its package status takes precedence over its subclass status\202.
)QB(

)0 4 H(Public)EH(
)BQ(
Now for the easiest access specifier--public. To declare a public variable,
use the keyword )SM(public)ES(. For example,
)BQ(
)PR(
class Alpha {
    public int iampublic;
}
)RP(
)QB(
Any class, in any package, has access to a class's public variables.
For example, this version of the Beta class
)BQ(
)PR(
class Beta {
    void accessMethod\201\202 {
	Alpha a = new Alpha\201\202;
        a.iampublic = 10;	// legal
    }
}
)RP(
)QB(
can legally inspect and modify the )SM(iampublic)ES( variable
in the Alpha class.
)QB(

)0 4 H(Friendly)EH(
)BQ(
And finally, the last access level is what you get if you don't
explicitly set a variable's access to one of the other levels.
For example, this version of the Alpha class declares a single
"friendly" variable and lives within the Greek package.
)BQ(
)PR(
package Greek;

class Alpha {
    int iamfriendly;
}
)RP(
)QB(
The Alpha class has access to )SM(iamfriendly)ES(. In
addition, all the classes declared within the same package as
Alpha also have access to )SM(iamfriendly)ES(.
For example, suppose that both Alpha and Beta were declared
as part of the Greek package, then this Beta class
)BQ(
)PR(
package Greek;

class Beta {
    void accessMethod\201\202 {
        Alpha a = new Alpha\201\202;
        a.iamprotected = 10;	// legal
    }
}
)RP(
)QB(
could legally access )SM(iamfriendly)ES(.
)QB(
)QB(

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Declaring a Class Variable
)EH(
)0 P(
)BQ(

By default, when you declare a variable within a class that variable
is an )I(instance variable)ES(. Every time you instantiate a new object
from the class, you get a new copy of each instance variable of that
class, and that copy is associated with the new object.
For example, the class defined below has one instance variable,
an integer named x.
)BQ(
)PR(
class AnIntegerNamedX {
    int x;
}
)RP(
)QB(
Every time you instantiate AnIntegerNamedX, you create an instance
of AnIntegerNamedX and each instance of AnIntegerNamedX gets its own
copy of )SM(x)ES(. To access a particular )SM(x)ES(, you
must access it through the object with which it is associated \201either
directly, if you have access, or through the instance's methods\202.
There is no other way to access )SM(x)ES( except through the 
instance. 
)0 P(
This code snippet creates two different objects of type AnIntegerNamedX,
sets their )SM(x)ES( values to different values, then prints
out the values.)EA(
)BQ(
)PR(
. . .
AnIntegerNamedX myX = new AnIntegerNamedX\201\202;
AnIntegerNamedX anotherX = new AnIntegerNamedX\201\202;
myX.x = 1;
anotherX.x = 2;
System.out.println\201"myX.x = " + myX.x\202;
System.out.println\201"anotherX.x = " + anotherX.x\202;
. . .
)RP(
)QB(
The output produced by this code snippet is
)BQ(
)PR(
myX.x = 1
anotherX.x = 2
)RP(
)QB(
illustrating that each instance of the class AnIntegerNamedX has its
own copy of the instance variable )SM(x)ES(.
)0 P(
However, when declaring a variable, you can specify that variable to
be a )I(class variable)ES( rather than an instance variable. The
system creates a single copy of a class variable the first time it
encounters the class in which the variable is defined. All instances
of that class share the same class variable.
)0 P(
To specify that a variable is a class variable, use the keyword
)SM(static)ES(. For example, let's change the AnIntegerNamedX
class such that its )SM(x)ES( variable is now a class variable
)BQ(
)PR(
class AnIntegerNamedX {
    static int x;
}
)RP(
)QB(
Now the exact same code snippet )A(from before)EA( that
creates two instances of AnIntegerNamedX, sets their )SM(x)ES( values,
and then prints the )SM(x)ES( values produces this, different, output.
)BQ(
)PR(
myX.x = 2
anotherX.x = 2
)RP(
)QB(
That's because now that )SM(x)ES( is a class variable there is only
one copy of the variable and it is shared by all instances of AnIntegerNamedX
including )SM(myX)ES( and )SM(anotherX)ES(.
)0 P(
You use class variables for items that you need only one copy of and which must
be accessible by all objects inheriting from the class in which the variable
is declared. For example, class variables are often used to define constants
\201this is more memory efficient as constants can't change so you really only
need one copy\202.

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Declaring a Constant
)EH(
)0 P(
)BQ(

To create a constant in Java use the keyword )SM(final)ES( in your
variable declaration. The following variable declaration defines a 
constant named AVOGADRO whose value is Avogadro's number \2016.023 x 10^23\202
and cannot be changed.
)BQ(
)PR(
final double AVOGADRO = 6.023e23;
)RP(
)QB(
By convention, names of constant values are spelled in all capital letters.
If your program ever tries to change a constant, the compiler will display
an error message similar to the following, and refuse to compile your program.
)BQ(
)PR(
AvogadroTest.java:5: Can't assign a value to a final variable: AVOGADRO
)RP(
)QB(

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Declaring a Transient Variable
)EH(
)0 P(
)BQ(

You use the )SM(transient)ES( keyword to indicate to the the Java
virtual machine that the indicated variable is not part of the persistent
state of the object. At this time, the Java virtual machine ignores the
)SM(transient)ES( marker. Future releases of the Java system will use
the )SM(transient)ES( marker to implement various object archiving
functions.
)0 P(
Like other variable modifiers in the Java system, you use )SM(transient)ES(
in a class or instance variable declaration like this
)BQ(
)PR(
class TransientExample {
    transient int hobo;
    . . .
}
)RP(
)QB(
This statement declares an integer variable named )SM(hobo)ES(
that is not part of the persistent state of the TransientExample class.

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Declaring a Volatile Variable
)EH(
)0 P(
)BQ(

When you are using threads that can modify the same variable, you can use
Java's )SM(volatile)ES( keyword to indicate that to the Java runtime
system. At this time, the Java runtime system does nothing with this
information. However, future releases of the Java runtime system will use
this information to ensure that the variable is loaded from memory before
each use, and stored to memory after each use to ensure that the value
of the variable is consistent and coherent within each thread.
)0 P(
The following variable declaration is an example of how to declare that
that a variable can be modified asynchronously by concurrent threads. 
)BQ(
)PR(
class VolatileExample {
    volatile int counter;
    . . .
}
)RP(
)QB(

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL NP(







)A()0 0 IM()EA()A()0 1 IM()EA()A()0 2 IM()EA()A()0 3 IM()EA(


)A()BD()I(Java Objects)ES()ES()EA(



)0 P(
)HR(

)0 2 H(
    Interfaces
)EH(
)0 P(
)BQ(

[PENDING: under construction]

)QB(
)0 P(
)HR(
)0 P(



)A()2 0 IM()EA()A()2 1 IM()EA()A()2 2 IM()EA()A()2 3 IM()EA(


)A()BD()I(Table of Contents)ES()ES()EA(





)WB NL showpage end restore
