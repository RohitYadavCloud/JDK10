<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 --> <HTML> <HEAD>
<TITLE>The Java(tm) White Paper: Java is Object Oriented</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING5></A>
<A HREF="java-whitepaper-6.html">Next</A>       <A HREF="java-whitepaper-4.html">Prev</A>              <A HREF="java-whitepaper-1.html">Contents</A><P>
<HR>
<H1>Java is Object Oriented</H1>
<DL>
<DT><A HREF="java-whitepaper-5.html#HEADING5-9"><B>	3.1	</B> - Object Technology in Java</A><DD>
<DT><A HREF="java-whitepaper-5.html#HEADING5-16"><B>	3.2	</B> - What Are Objects?</A><DD>
<DT><A HREF="java-whitepaper-5.html#HEADING5-22"><B>	3.3	</B> - Basics of Objects</A><DD>
<DT><A HREF="java-whitepaper-5.html#HEADING5-95"><B>	3.4	</B> - Summary</A><DD>
</DL>

<HR>
<A NAME=HEADING5-0></A>


 <P>
 My Object All Sublime<BR> I Will Achieve in Time<P>
 Gilbert and Sullivan--<I>The Mikado</I><P>
<P>
To stay abreast of modern software development practices, Java is <I>object oriented </I>from the ground<I> </I>up<I>.</I> The point of designing an object-oriented language is not simply to jump on the latest programming fad. The object-oriented paradigm meshes well with the needs of client-server and distributed software. Benefits of object technology are rapidly becoming realized as more organizations move their applications to the distributed client-server model.<P>
Unfortunately, "object oriented" remains misunderstood, over-marketed as the silver bullet that will solve all our software ills, or takes on the trappings of a religion. The cynic's view of object-oriented programming is that it's just a new way to organize your source code. While there may be some merit to this view, it doesn't tell the whole story, because you can achieve results with object-oriented programming techniques that you can't with procedural techniques.<P>
An important characteristic that distinguishes objects from ordinary procedures or functions is that an object can have a lifetime greater than that of the object that created it. This aspect of objects is subtle and mostly overlooked.In the distributed client-server world, this creates the potential for objects to be created in one place, passed around networks, and stored elsewhere, possibly in databases, to be retrieved for future work.<P>
As an object-oriented language, Java draws on the best concepts and features of previous object-oriented languages, primarily Eiffel, SmallTalk, Objective C, and C++. Java goes beyond C++ in both extending the object model and removing the major complexities of C++. With the exception of its primitive data types, everything in Java is an object, and even the primitive types can be encapsulated within objects if the need arises.<P>
<A NAME=HEADING5-10></A>
<HR>
<H2> 3.1 Object Technology in Java</H2>
To be truly considered "object oriented", a programming language should support at a minimum four characteristics:<P>
<UL>
<LI><I>Encapsulation</I>--implements information hiding and modularity (abstraction)<P>
<LI><I>Polymorphism</I>--the same message sent to different objects results in behavior that's dependent on the nature of the object receiving the message<P>
<LI><I>Inheritance</I>--you define new classes and behavior based on existing classes to obtain code re-use and code organization<P>
<LI><I>Dynamic binding</I>--objects could come from anywhere, possibly across the network. You need to be able to send messages to objects without having to know their specific type at the time you write your code. Dynamic binding provides maximum flexibility while a program is executing<P>
</UL>
Java meets these requirements nicely, and adds considerable run-time support to make your software development job easier.<P>
<A NAME=HEADING5-17></A>
<HR>
<H2> 3.2 What Are Objects?</H2>
At its simplest, object technology is a collection of analysis, design, and programming methodologies that focuses design on <I>modelling</I> the characteristics and behavior of objects in the real world. True, this definition appears to be somewhat circular, so let's try to break out into clear air.<P>
What are objects? They're software programming <I>models</I>. In your everyday life, you're surrounded by objects: cars, coffee machines, ducks, trees, and so on. Software applications contain objects: buttons on user interfaces, spreadsheets and spreadsheet cells, property lists, menus, and so on. These objects have <I>state</I> and <I>behavior</I>. You can represent all these things with software constructs called objects, which can also be defined by their <I>state</I> and their <I>behavior</I>.<P>
In your everyday transportation needs, a <I>car</I> can be modelled by an object. A car has <I>state</I> (how fast it's going, in which direction, its fuel consumption, and so on) and <I>behavior</I> (starts, stops, turns, slides, and runs into trees).<P>
You drive your car to your office, where you track your stock portfolio. In your daily interactions with the stock markets, a <I>stock</I> can be modelled by an object. A stock has <I>state</I> (daily high, daily low, open price, close price, earnings per share, relative strength), and <I>behavior</I> (changes value, performs splits, has dividends).<P>
After watching your stock decline in price, you repair to the cafe to console yourself with a cup of good hot coffee. The <I>espresso machine</I> can be modelled as an object. It has <I>state</I> (water temperature, amount of coffee in the hopper) and it has <I>behavior</I> (emits steam, makes noise, and brews a perfect cup of <I>java</I>).<P>
<A NAME=HEADING5-23></A>
<HR>
<H2> 3.3 Basics of Objects</H2>
<IMG SRC="java-whitepaper-5-image-1.gif">In the programming implementation of an object, its <I>state</I> is defined by its <I>instance variables</I>. Instance variables are private to the object. Unless explicitly made public or made available to other "friendly" classes, an object's instance variables are inaccessible from outside the object. <P>
An object's <I>behavior</I> is defined by its <I>methods</I>. Methods manipulate the instance variables to create new state; an object's methods can also create new objects. <P>
The small picture to the left is a commonly used graphical representation of an object. The diagram illustrates the conceptual structure of a software object--it's kind of like a cell, with an outer membrane that's its interface to the world, and an inner nucleus that's protected by the outer membrane.<P>
An object's <EM>instance variables</EM> (data) are packaged, or encapsulated, within the object. The instance variables are surrounded by the object's <I>methods</I>. With certain well-defined exceptions, the object's methods are the only means by which other objects can access or alter its instance variables. In Java, classes can declare their instance variables to be <CODE>public</CODE>, in which cases the instance variables are globally accessible to other objects. Declarations of accessibility are covered in later in <EM>Access Specifiers</EM>.<P>
<H3> 3.3.1 Classes</H3>
A <I>class</I> is a software construct that defines the <I>instance variables</I> and <I>methods</I> of an object. A class in and of itself is not an object. A class is a <I>template</I> that defines how an object will look and behave when the object is created or <I>instantiated</I> from the specification declared by the class. You obtain concrete objects by instantiating a previously defined class. You can instantiate many objects from one class definition, just as you can construct many houses that area all the same from a single architect's drawing. Here's the basic declaration of a very simple class called Point<P>
<PRE>
    class Point extends Object {
        public double  x;    /*  <I>instance variable</I>  */
        public double  y;    /*  <I>instance variable</I>  */
    }
</PRE>
As mentioned, this declaration merely defines a template from which real objects can be instantiated, as described next.<P>
<H3> 3.3.2 Instantiating an Object from its Class</H3>
Having declared the size and shape of the Point <I>class</I> above, any other object can now create a <CODE>Point</CODE> <I>object</I>--an instance of the <CODE>Point</CODE> class--with a fragment of code like this:<P>
<PRE>
    Point  myPoint;          //  <I>declares a variable to refer to a</I> Point <I>object
</I>
    myPoint = new Point();   //  <I>allocates an instance of  a</I> Point <I>object</I>
</PRE>
Now, you can access the variables of this Point object by referring to the names of the variables, qualified with the name of the object:<P>
<PRE>
    myPoint.x = 10.0;
    myPoint.y = 25.7;
</PRE>
This referencing scheme, similar to a C structure reference, works because the instance variables of <CODE>Point</CODE> were declared <CODE>public</CODE> in the class declaration. Had the instance variables not been declared <CODE>public</CODE>, objects outside of the package within which <CODE>Point</CODE> was declared could not access its instance variables in this direct manner. The <CODE>Point</CODE> class declaration would then need to provide <I>accessor methods</I> to set and get its variables. This topic is discussed in a little more detail after the discussion on constructors. <P>
<H3> 3.3.3 Constructors</H3>
When you declare a class in Java, you can declare optional <I>constructors</I> that perform initialization when you instantiate objects from that class. You can also declare an optional <I>finalizer</I>, discussed later. Let's go back to our <CODE>Point</CODE> class from before:<P>
<PRE>
    class Point extends Object {
        public double  x;    /*  <I>instance variable</I>  */
        public double  y;    /*  <I>instance variable</I>  */
    
        Point() {        /*  <I>constructor to initialize to default zero value</I>  */
            x = 0.0;
            y = 0.0;
        }
                        /*  <I>constructor to initialize to specific value</I>  */
        Point(double x, double y) {
            this.x = x;    /*  <I>set instance variables to passed parameters</I>  */
            this.y = y;
        }
    }
</PRE>
Methods with the same name as the class as in the code fragment are called <I>constructors</I>. When you create (instantiate) an object of the <CODE>Point</CODE> class, the constructor method is invoked to perform any initialization that's needed--in this case, to set the instance variables to an initial state.<P>
This example is a variation on the <CODE>Point</CODE> class from before. Now, when you wish to create and initialize <CODE>Point</CODE> objects, you can get them initialized to their default values, or you can initialize them to specific values:<P>
<PRE>
    Point  lowerLeft;
    Point  upperRight;

    lowerLeft = new Point();        /* <I> initialize to default zero value</I>  */
    upperRight = new Point(100.0, 200.0);  /* <I> initialize to non- zero </I>  */
</PRE>
The specific constructor that's used when creating a new <CODE>Point</CODE> object is determined from the type and number of parameters in the <CODE>new</CODE> invocation.<P>
<B>The this Variable</B><P>
What's the <CODE>this</CODE> variable in the examples above? <CODE>this</CODE> refers to the object you're "in" right now. In other words, <CODE>this</CODE> refers to the receiving object. You use <CODE>this</CODE> to clarify which variable you're referring to. In the two-parameter <CODE>Point</CODE> method, <CODE>this.x</CODE> means the <CODE>x</CODE> instance variable of this object, rather than the <CODE>x</CODE> parameter to the <CODE>Point</CODE> method.<P>
In the example above, the constructors are simply conveniences for the <CODE>Point</CODE> class. There are situations, however, where constructors are necessary, especially in cases where the object being instantiated must itself instantiate other objects. Let's illustrate this by declaring a <CODE>Rectangle</CODE> class that uses two <CODE>Point</CODE> objects to define its bounds:<P>
<PRE>
    class Rectangle extends Object {
       private Point lowerLeft;
        private Point upperRight;

        Rectangle() {
            lowerLeft = new Point();
            upperRight = new Point();
        }
            . . .
         <I>instance methods appear in here
</I>            . . .
    }
</PRE>
In this example, the <CODE>Rectangle()</CODE> constructor is vitally necessary to ensure that the two <CODE>Point</CODE> objects are instantiated at the time a <CODE>Rectangle</CODE> object is instantiated, otherwise, the <CODE>Rectangle</CODE> object would subsequently try to reference points that have not yet been allocated, and would fail.<P>
<H3> 3.3.4 Methods and Messaging</H3>
<IMG SRC="java-whitepaper-5-image-2.gif">If an object wants another object to do some work on its behalf, then in the parlance of object-oriented programming, the first object sends a <I>message</I> to the second object. In response, the second object selects the appropriate <I>method</I> to invoke. Java method invocations look similar to functions in C and C++.<P>
Using the message passing paradigms of object-oriented programming, you can build entire networks and webs of objects that pass messages between them to change state. This programming technique is one of the best ways to create models and simulations of complex real-world systems. Let's redefine the declaration of the <CODE>Point</CODE> class from above such that its instance variables are <CODE>private</CODE>, and supply it with <I>accessor methods</I> to access those variables.<P>
<PRE>
    class Point extends Object {
        private double  x;    /*  <I>instance variable</I>  */
        private double  y;    /*  <I>instance variable</I>  */
    
        Point() {    /*  <I>constructor to initialize to zero</I>  */
            x = 0.0;
            y = 0.0;
        }
                           /*  <I>constructor to initialize to specific value</I>  */
        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
        public void setX(double x) {    /*  <I>accessor method</I>  */
            this.x = x;
        }
        public void setY(double y) {    /*  <I>accessor method</I>  */
            this.y = y;
        }
        public double getX() {    /*  <I>accessor method</I>  */
            return x;
        }
        public double getY() {    /*  <I>accessor method</I>  */
            return y;
        }
    }
</PRE>
These method declarations provides the flavor of how the <CODE>Point</CODE> class provides access to its variables from the outside world. Another object that wants to manipulate the instance variables of <CODE>Point</CODE> objects must now do so via the accessor methods:<P>
<PRE>
    Point  myPoint;          //  <I>declares a variable to refer to a</I> Point <I>object
</I>
    myPoint = new Point();   //  <I>allocates an instance of  a</I> Point <I>object</I>
    myPoint.setX(10.0);      //  <I>sets the x variable via the accessor method
</I>    myPoint.setY(25.7);
</PRE>
Making instance variables public or private is a design tradeoff the designer makes when declaring the classes. By making instance variables public, you are exposing some of the details of the implementation of the class, thereby providing higher efficiency and conciseness of expression at the possible expense of hindering future maintenance efforts. By hiding details of the internal implementation of a class, you have the potential to change the implementation of the class in the future without breaking any code that uses that class.<P>
<H3> 3.3.5 Finalizers</H3>
You can also declare an optional <I>finalizer</I> that will perform necessary tear-down actions when the garbage collector is about to free an object. This code fragment illustrates a <CODE>finalize</CODE> method in a class. <P>
<PRE>
    /**
      * Close the stream when garbage is collected.
      */  
    protected void finalize() {
        try {
            file.close();
        } catch (Exception e) {
        }
    } 
</PRE>
This <CODE>finalize</CODE> method will be invoked when the object is about to be garbage collected, which means that the object must shut itself down in an orderly fashion. In the particular code fragment above, the <CODE>finalize</CODE> method merely closes an I/O file stream that was used by the object, to ensure that the file descriptor for the stream is closed. <P>
<H3> 3.3.6 Subclassing</H3>
<I>Subclassing</I> is the mechanism by which new and enhanced objects can be defined in terms of existing objects. One example: a zebra is a horse with stripes. If you wish to create a zebra object, you notice that a zebra is kind of like a horse, only with stripes. In object-oriented terms, you'd create a new class called Zebra, which is a <I>subclass</I> of the Horse class. In Java language terms, you'd do something like this:<P>
<PRE>
    class Zebra extends Horse {
        Your new instance variables and new methods go here
    }
</PRE>
The definition of <CODE>Horse</CODE>, wherever it is, would define all the methods to describe the <I>behavior</I> of a horse: eat, neigh, trot, gallop, buck, and so on. The only method you need to override is the method for drawing the hide. You gain the benefit of already written code that does all the work--you don't have to re-invent the wheel, or in this case, the hoof. The <CODE>extends</CODE> keyword tells the Java compiler that Zebra is a subclass of Horse. Zebra is said to be a <I>derived class</I>--it's derived from Horse, which is called a <I>base class</I>. <P>
Here's an example of subclassing a variant of our <CODE>Point</CODE> class from previous examples to create a new three-dimensional point called <CODE>ThreePoint</CODE>:<P>
<PRE>
    class Point extends Object {
        protected double  x;    /*  <I>instance variable</I>  */
        protected double  y;    /*  <I>instance variable</I>  */
    
        Point() {    /*  <I>constructor to initialize to zero</I>  */
            x = 0.0;
            y = 0.0;
        }
    }
    class ThreePoint extends Point {
        protected double z;    /*  <I>the z coordinate of the point</I>  */
        
        ThreePoint() {      /*  <I>default constructor</I>  */
            x = 0.0;        /*  <I>initialize the coordinates</I>  */
            y = 0.0;
            z = 0.0;
        }
        ThreePoint(double x, double y, double z) {/* <I>specific constructor</I> */
            this.x = x;        /*  <I>initialize the coordinates</I>  */
            this.y = y;
            this.z = z;
        }
    }
</PRE>
Notice that <CODE>ThreePoint</CODE> adds a new instance variable for the <I>z</I> coordinate of the point. The <I>x</I> and <I>y</I> instance variables are <I>inherited</I> from the original <CODE>Point</CODE> class, so there's no need to declare them in <CODE>ThreePoint</CODE>. However, notice we had to make <CODE>Point</CODE>'s instance variables <CODE>protected</CODE> instead of <CODE>private</CODE> as in the previous examples. Had we left <CODE>Point</CODE>'s instance variables <CODE>private</CODE>, even its subclasses would be unable to access them, and the compilation would fail.<P>
Subclassing enables you to use existing code that's already been developed and, much more important, tested, for a more generic case. You override the parts of the class you need for your specific behavior. Thus, subclassing gains you reuse of existing code--you save on design, development, and testing. The Java run-time system provides several libraries of utility functions that are tested and are also <I>thread safe</I>. <P>
<H3> 3.3.7 Access Control</H3>
When you declare a new class in Java, you can indicate the level of access permitted to its instance variables and methods. Java provides four levels of access specifiers. Three of the levels must be explicitly specified if you wish to use them. They are <CODE>public</CODE>, <CODE>protected</CODE>, and <CODE>private</CODE>.<P>
The fourth level doesn't have a name--it's often called "friendly" and is the access level you obtain if you don't specify otherwise. The "friendly" access level indicates that your instance variables and methods are accessible to all objects within the same package, but inaccessible to objects outside the package.<P>
The friendly access level comes in handy if you're creating <I>packages</I> of classes that are related to each other and can access each other's instance variables directly. A geometry package consisting of <CODE>Point</CODE> and <CODE>Rectangle</CODE> classes, for instance, might well be easier and cleaner to implement, as well as more efficient, if the <CODE>Point</CODE>'s instance variables were directly available to the <CODE>Rectangle</CODE> class. Outside of the geometry package, however, the details of implementations are hidden from the rest of the world, giving you the freedom to changed implementation details without worrying you'll break code that uses those classes. Packages are a Java language construct that gather collections of related classes into a single container. For example, all Java I/O system code is collected into a single package. The primary benefit of packages is organizing many class definitions into a single unit. The secondary benefit from the programmer's viewpoint is that the "friendly" instance variables and methods are available to all classes within the same package, but not to classes defined outside the package. <P>
<CODE>public</CODE> methods and instance variables are available to any other class anywhere.<P>
<CODE>protected</CODE> means that instance variables and methods so designated are accessible only to subclasses of that class, and nowhere else. <P>
<CODE>private</CODE> methods and instance variables are accessible only from within the class in which they're declared--they're not available even to their subclasses.<P>
<H3> 3.3.8 Class Variables and Class Methods</H3>
Java follows conventions from other object-oriented languages in providing <I>class methods</I> and <I>class variables</I>. Normally, variables you declare in a class definition are <I>instance variables</I>--there is one of those variables in every separate object that's created (instantiated) from the class. A class variable, on the other hand, is local to the class itself--there's only a single copy of the variable and it's shared by every object you instantiate from the class. <P>
To declare class variables and class methods, you declare them as <CODE>static</CODE>. This short code fragment illustrates the declaration of class variables:<P>
<PRE>
    class Rectangle extends Object {
        static  final int version = 2;
        static  final int revision = 0;
    } 
</PRE>
The <CODE>Rectangle</CODE> class declares two <CODE>static</CODE> variables to define the version and revision level of this class. Now, every instance of Rectangle that you create from this class will share these same variables. Notice they're also defined as <CODE>final</CODE> because you want them to be constants.<P>
Class methods are methods that are common to an entire class. When would you use class methods? Usually, when you have behavior that's common to every object of a class. For example, suppose you have a <CODE>Window</CODE> class. A useful item of information you can ask the class is the width of the border around the window. There's no point in having an instance method to obtain this information that's shared by every instance of <CODE>Window</CODE>--it makes more sense to have just one class method to return the border width.<P>
Class methods can operate <I>only</I> on class variables. Class methods can't access instance variables, nor can they invoke instance methods. Like class variables, you declare class methods by defining them as <CODE>static</CODE>.<P>
<H3> 3.3.9 Abstract Methods</H3>
Abstract methods are a powerful construct in the object-oriented paradigm. To understand abstract methods, we look at the notion of an <I>abstract superclass</I>. An abstract superclass is a class in which you define methods that aren't actually implemented by that class--they only provide place-holders such that subsequent subclasses must override those methods and supply their actual implementation.<P>
This all sounds wonderfully, well, <I>abstract</I>, so why would you need an abstract superclass? Let's look at a <I>concrete</I> example, no pun intended. Let's suppose you're going to a restaurant for dinner, and you decide that tonight you want to eat fish. Well, <I>fish</I> is somewhat abstract--you generally wouldn't just order fish; the waiter is highly likely to ask you what <I>specific</I> kind of fish you want. When you actually get to the restaurant, you will find out what kind of fish they have, and order a specific fish, say, sturgeon, or salmon, or opakapaka.<P>
In the world of objects, an abstract class is like generic fish--the abstract class defines generic state and generic behavior, but you'll never see a real live implementation of an abstract class. What you will see is a <I>concrete subclass</I> of the abstract class, just as opakapaka is a specific (concrete) kind of fish.<P>
Suppose you are creating a drawing application. The initial cut of your application can draw rectangles, lines, circles, polygons, and so on. Furthermore, you have a series of operations you can perform on the shapes--move, reshape, rotate, fill color, and so on. You <I>could</I> make each of these graphic shapes a separate class--you'd have a Rectangle class, a Line class, and so on. Each class needs instance variables to define its position, size, color, rotation and so on, which in turn dictates methods to set and get at those variables.<P>
At this point, you realize you can collect all the instance variables into a single abstract superclass called <CODE>Graphical</CODE>, and implement most of the methods to manipulate the variables in that abstract superclass. The skeleton of your abstract superclass might look something like this:<P>
<PRE>
abstract class Graphic extends Object {
    protected Point lowerLeft;            //  <I>lower left of bounding box
</I>    protected Point upperRight;           //  <I>upper right of bounding box
</I>                     . . .
                <I>more instance variables
</I>                     . . .
    public void setPosition(Point ll, Point ur) {
        lowerLeft = ll;
        upperRight = ur;
    }
    abstract void drawMyself();   //  <I>abstract method
</I>    }

}
</PRE>
Now, you can't instantiate the <CODE>Graphical</CODE> class, because it's declared <CODE>abstract</CODE>. You can only instantiate a <I>subclass</I> of it. When you implement the <CODE>Rectangle</CODE> class or the <CODE>Circle</CODE> class, you'd extend (subclass) <CODE>Graphical</CODE>. Within <CODE>Rectangle</CODE>, you'd provide a <I>concrete</I> implementation of the <CODE>drawMySelf()</CODE> method that draws a rectangle, because the definition of <CODE>drawMySelf()</CODE> must by necessity be unique to each shape inherited from the <CODE>Graphical</CODE> class. Let's see a small fragment of the <CODE>Rectangle</CODE> class declaration, where its <CODE>drawMySelf()</CODE> method operates in a somewhat PostScript'y fashion:<P>
<PRE>
abstract class Rectangle extends Graphical {
    void drawMySelf() {         //  <I>really does the drawing
</I>        moveTo(lowerLeft.x, lowerLeft.y);
        lineTo(upperRight.x, lowerLeft.y);
        lineTo(upperRight.x, upperRight.y)
        lineTo(lowerLeft.x, upperRight.y);
                     . . .
                  <I>and so on and so on
</I>                     . . .
    }
}
</PRE>
Notice, however, that in the declaration of the <CODE>Graphical</CODE> class, the <CODE>setPosition()</CODE> method was declared as a regular (<CODE>public void</CODE>) method. All methods that <I>can</I> be implemented by the abstract superclass can be declared there and their implementations defined at that time. Then, every class that inherits from the abstract superclass will also inherit those methods.<P>
You can continue in this way adding new shapes that are subclasses of <CODE>Graphical</CODE>, and most of the time, all you ever need to implement is the methods that are unique to the specific shape. You gain the benefit of re-using all the code that was defined inside the abstract superclass.<P>
<A NAME=HEADING5-96></A>
<HR>
<H2> 3.4 Summary</H2>
This chapter has conveyed the essential aspects of Java as an <I>object-oriented</I> language. To sum up:<P>
<UL>
<LI><I>Classes</I> define templates from which you <I>instantiate</I> (create) distinct concrete <I>objects</I>.<P>
<LI><I>Instance variables</I> hold the <I>state</I> of a specific object.<P>
<LI>Objects communicate by sending <I>messages</I> to each other. Objects respond to messages by selecting a <I>method</I> to execute.<P>
<LI><I>Methods</I> define the <I>behavior</I> of objects instantiated from a class. It is an object's methods that manipulate its instance variables. Unlike regular procedural languages, classes in an object-oriented language may have methods with the same names as other classes. A given object responds to a message in ways determined by the nature of that object, providing <I>polymorphic</I> behavior.<P>
<LI><I>Subclassing</I> provides the means by which a new class can <I>inherit</I> instance variables and methods from any already defined class. The newly declared class can add new instance variables (extra state), can add new methods (new behavior), or can <I>override</I> the methods of its superclass (different behavior). Subclassing provides code reuse.<P>
</UL>
Taken together, the concepts of object-oriented programming create a powerful and simple paradigm for software developers to share and re-use code and build on the work of others.<P>
<HR>
<A HREF="java-whitepaper-6.html">Next</A>       <A HREF="java-whitepaper-4.html">Prev</A>              <A HREF="java-whitepaper-1.html">Contents</A><P>
<B>The Java(tm) Language Environment: A White Paper</B><P>
</BODY>
</HTML> 