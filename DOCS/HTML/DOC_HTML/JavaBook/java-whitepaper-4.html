<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 --> <HTML> <HEAD>
<TITLE>The Java(tm) White Paper: Java--Simple and Familiar</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING4></A>
<A HREF="java-whitepaper-5.html">Next</A>       <A HREF="java-whitepaper-3.html">Prev</A>              <A HREF="java-whitepaper-1.html">Contents</A><P>
<HR>
<H1>Java--Simple and Familiar</H1>
<DL>
<DT><A HREF="java-whitepaper-4.html#HEADING4-15"><B>	2.1	</B> - Main Features of the Java Language</A><DD>
<DT><A HREF="java-whitepaper-4.html#HEADING4-70"><B>	2.2	</B> - Features Removed from C and C++</A><DD>
<DT><A HREF="java-whitepaper-4.html#HEADING4-111"><B>	2.3	</B> - Summary</A><DD>
</DL>

<HR>
<A NAME=HEADING4-0></A>


 You know you've achieved perfection in design,<BR> Not when you have nothing more to add,<BR> But when you have nothing more to take away.<P>
 Antoine de Saint Exupery.<P>
<P>
<P>
In his science-fiction novel, <I>The Rolling Stones</I>, Robert A. Heinlein comments:<P>
<I><I>Every technology goes through three stages: first a crudely simple and quite unsatisfactory gadget; second, an enormously complicated group of gadgets designed to overcome the shortcomings of the original and achieving thereby somewhat satisfactory performance through extremely complex compromise; third, a final proper design therefrom</I>.<P></I>
Heinlein's comment could well describe the evolution of many programming languages. Java presents a new viewpoint in the evolution of programming languages--creation of a small and simple language that's still sufficiently comprehensive to address a wide variety of software application development. While Java superficially like C and C++, Java gained its simplicity from the systematic removal of features from its predecessors. This chapter discusses two of the primary design features of Java, namely, it's <I>simple</I> (from removing features) and <I>familiar</I> (because it looks like C and C++). The next chapter discusses Java's <I>object-oriented</I> features in more detail. At the end of this chapter you'll find a discussion on features eliminated from C and C++ in the evolution of Java.<P>
<B>Design Goals</B><P>
<I>Simplicity</I> is one of Java's overriding design goals. Simplicity and removal of many "features" of dubious worth from its C and C++-based ancestors keep Java relatively small and reduce the programmer's burden in producing reliable applications. To this end, Java design team examined many aspects of the "modern" C and C++ languages<A HREF="#FOOTNOTE-1">[1]</A> to determine features that could be eliminated in the context of modern object-oriented programming.<P>
Another major design goal is that Java look <I>familiar</I> to a majority of programmers in the personal computer and workstation arenas, where a large fraction of system programmers and application programmers are familiar with C and C++. Thus, Java "looks like" C++. Programmers familiar with C, Objective C, C++, Eiffel, Ada, and related languages should find their Java language learning curve quite short--on the order of a couple of weeks.<P>
To illustrate the simple and familiar aspects of Java, we follow the tradition of a long line of illustrious programming books by showing you the <CODE>HelloWorld</CODE> program. It's about the simplest program you can write that actually does something. Here's <CODE>HelloWorld</CODE> implemented in Java.<P>
<PRE>
    class HelloWorld {
        static public void main(String args[]) {
            System.out.println(&quot;Hello world!&quot;);
        }
    }
</PRE>
This example declares a class named <CODE>HelloWorld</CODE>. Classes are discussed in the next chapter on object-oriented programming, but in general we assume the reader is familiar with object technology and understands the basics of classes, objects, instance variables, and methods.<P>
Within the <CODE>HelloWorld</CODE> class, we declare a single method called <CODE>main()</CODE> which in turn contains a single method invocation to display the string &quot;Hello world!&quot; on the standard output. The statement that prints &quot;Hello world!&quot; does so by invoking the <CODE>println</CODE> method of the <CODE>out</CODE> object. The <CODE>out</CODE> object is a class variable in the <CODE>System</CODE> class that performs output operations on files. That's all there is to <CODE>HelloWorld</CODE>.<P>
<A NAME=HEADING4-16></A>
<HR>
<H2> 2.1 Main Features of the Java Language</H2>
Java follows C++ to some degree, which carries the benefit of it being familiar to many programmers. This section describes the essential features of Java and points out where the language diverges from its ancestors C and C++.<P>
<H3> 2.1.1 Primitive Data Types</H3>
Other than the primitive data types discussed here, everything in Java is an object. Even the primitive data types can be encapsulated inside library-supplied objects if required. Java follows C and C++ fairly closely in its set of basic data types, with a couple of minor exceptions. There are only three groups of primitive data types, namely, <I>numeric</I> types, <I>Boolean</I> types, and <I>arrays</I>.<P>
<B>Numeric Data Types</B><P>
Integer numeric types are 8-bit <CODE>byte</CODE>, 16-bit <CODE>short</CODE>, 32-bit <CODE>int</CODE>, and 64-bit <CODE>long</CODE>. The 8-bit <CODE>byte</CODE> data type in Java has replaced the old C and C++ <CODE>char</CODE> data type. Java places a different interpretation on the <CODE>char</CODE> data type, as discussed below.<P>
There is no <CODE>unsigned</CODE> type specifier for integer data types in Java.<P>
Real numeric types are 32-bit <CODE>float</CODE> and 64-bit <CODE>double</CODE>. Real numeric types and their arithmetic operations are as defined by the IEEE 754 specification. A floating point <I>literal</I> value, like <CODE>23.79</CODE>, is considered <CODE>double</CODE> by default; you must explicitly cast it to <CODE>float</CODE> if you wish to assign it to a <CODE>float</CODE> variable.<P>
<B>Character Data Types</B><P>
Java language<I> character</I> data is a departure from traditional C. Java's <CODE>char</CODE> data type defines a sixteen-bit <I>Unicode</I> character. Unicode characters are unsigned 16-bit values that define character codes in the range 0 through 65,535. If you write a declaration such as<P>
<PRE>
    char  myChar = 'Q';
</PRE>
you get a Unicode (16-bit unsigned value) type that's initialized to the Unicode value of the character Q. By adopting the Unicode character set standard for its character data type, Java language applications are amenable to internationalization and localization, greatly expanding the market for world-wide applications.<P>
<B>Boolean Data Types</B><P>
Java has added a <CODE>boolean</CODE> data type as a primitive type, tacitly ratifying existing C and C++ programming practice, where developers define keywords for TRUE and FALSE or YES and NO or similar constructs. A Java <CODE>boolean</CODE> variable assumes the value <CODE>true</CODE> or <CODE>false</CODE>. A Java <CODE>boolean</CODE> is a distinct data type; unlike common C practice, a Java <CODE>boolean</CODE> type can't be converted to any numeric type.<P>
<H3> 2.1.2 Arithmetic and Relational Operators</H3>
All the familiar C and C++ operators apply. Because Java lacks <CODE>unsigned</CODE> data types, the <CODE>&gt;&gt;&gt;</CODE> operator has been added to the language to indicate an unsigned (logical) right shift. Java also uses the <CODE>+</CODE> operator for string concatenation; concatenation is covered below in the discussion on strings. <P>
<H3> 2.1.3 Arrays</H3>
In contrast to C and C++, Java language <I>arrays</I> are first-class language objects. An array in Java is a real object with a run-time representation. You can declare and allocate arrays of any type, and you can allocate arrays of arrays to obtain multi-dimensional arrays. <P>
You declare an array of, say, <CODE>Point</CODE>s (a class you've declared elsewhere) with a declaration like this:<P>
<PRE>
    Point  myPoints[];
</PRE>
This code states that <CODE>myPoints</CODE> is an uninitialized array of <CODE>Point</CODE>s. At this time, the only storage allocated for myPoints is a reference handle. At some future time you must allocate the amount of storage you need, as in:<P>
<PRE>
    myPoints = new Point[10];
</PRE>
to allocate an array of ten references to <CODE>Point</CODE>s that are initialized to the null reference. Notice that this allocation of an array doesn't actually allocate any objects of the Point class for you; you will have to also allocate the Point objects, something like this:<P>
<PRE>
    int  i;
    
    for (i = 0;  i &lt; 10;  i++) {
        myPoints<CODE>[i] = new Point();
</CODE>    }
</PRE>
Access to elements of <CODE>myPoints</CODE> can be performed via the normal C-style indexing, but all array accesses are checked to ensure that their indices are within the range of the array. An <I>exception</I> is generated if the index is outside the bounds of the array.<P>
To get the length of an array, use the <CODE>length()</CODE> <I>accessor method</I> on the array object whose length you wish to know: <CODE>myPoints.length()</CODE> returns the number of elements in <CODE>myPoints</CODE>. For instance, the code fragment:<P>
<PRE>
    howMany = myPoints<CODE>.length();</CODE>
</PRE>
would assign the value 10 to the <CODE>howMany</CODE> variable.<P>
The C notion of a pointer to an array of memory elements is gone, and with it, the arbitrary pointer arithmetic that leads to unreliable code in C. No longer can you walk off the end of an array, possibly trashing memory and leading to the famous "delayed-crash" syndrome, where a memory-access violation today manifests itself hours or days later. Programmers can be confident that array checking in Java will lead to more robust and reliable code.<P>
<H3> 2.1.4 Strings</H3>
Strings are Java language objects, not pseudo-arrays of characters as in C. There are actually two kinds of string objects: the <CODE>String</CODE> class is for read-only (immutable) objects. The <CODE>StringBuffer</CODE> class is for string objects you wish to modify (mutable string objects).<P>
Although strings are Java language objects, Java compiler follows the C tradition of providing a syntactic convenience that C programmers have enjoyed with C-style strings, namely, the Java compiler understands that a string of characters enclosed in double quote signs is to be instantiated as a <CODE>String</CODE> object. Thus, the declaration:<P>
<PRE>
    String hello = &quot;Hello world!&quot;;
</PRE>
instantiates an object of the String class behind the scenes and initializes it with a character string containing the Unicode character representation of &quot;Hello world!&quot;. <P>
Java has extended the meaning of the + operator to indicate <I>string concatenation</I>. Thus you can write statements like:<P>
<PRE>
System.out.println(&quot;There are &quot; + num + &quot; characters in the file.&quot;);
</PRE>
This code fragment concatenates the string <CODE>&quot;There are &quot;</CODE> with the result of converting the numeric value <CODE>num</CODE> to a string, and concatenates that with the string<CODE> &quot; characters in the file.&quot;</CODE>. Then it prints the result of those concatenations on the standard output.<P>
Just as with array objects, <CODE>String</CODE> objects provide a <CODE>length()</CODE> accessor method to obtain the number of characters in the string.<P>
<H3> 2.1.5 Multi-Level Break</H3>
Java has no <CODE>goto</CODE> statement. To <CODE>break</CODE> or <CODE>continue</CODE> multiple-nested loop or switch constructs, you can place labels on loop and <CODE>switch</CODE> constructs, and then <CODE>break</CODE> out of or <CODE>continue</CODE> to the block named by the label. Here's a small fragment of code from Java's built-in <CODE>String</CODE> class:<P>
<PRE>

test:  for (int i = fromIndex; i + max1 &lt;= max2; i++) {
           if (charAt(i) == c0) {
               for (int k = 1; k&lt;max1; k++) {
                   if (charAt(i+k) != str.charAt(k)) {
                       continue test;
                   }
               }     /*  end of inner for loop  */
           }
       }             /*  end of outer for loop  */
</PRE>
<BR>The <CODE>continue</CODE> <CODE>test</CODE> statement is inside a <CODE>for</CODE> loop nested inside another <CODE>for</CODE> loop. By referencing the label <CODE>test</CODE>, the <CODE>continue</CODE> statement passes control to the outer <CODE>for</CODE> statement. In traditional C, <CODE>continue</CODE> statements can only continue the immediately enclosing block; to continue or exit outer blocks, programmers have traditionally either used auxiliary Boolean variables whose only purpose is to determine if the outer block is to be continued or exited; alternatively, programmers have (mis)used the <CODE>goto</CODE> statement to exit out of nested blocks. Use of labelled blocks in Java leads to considerable simplification in programming effort and a major reduction in maintenance.<P>
The notion of labelled blocks dates back to the mid-1970s, but it hasn't caught on to any large extent in modern programming languages. Perl is another modern programming language that implements the concept of labelled blocks. Perl's <CODE>next</CODE> <I>label</I> and <CODE>last</CODE> <I>label</I> are equivalent to <CODE>continue</CODE> <I>label</I> and <CODE>break</CODE> <I>label</I> statements in Java.<P>
<H3> 2.1.6 Memory Management and Garbage Collection</H3>
C and C++ programmers are by now accustomed to the problems of explicitly managing memory: allocating memory, freeing memory, and keeping track of what memory can be freed when. Explicit memory management has proved to be a fruitful source of bugs, crashes, memory leaks, and poor performance.<P>
Java completely removes the memory management load from the programmer. C-style pointers, pointer arithmetic, <CODE>malloc,</CODE> and <CODE>free</CODE> do not exist. <I>Automatic</I> <I>garbage collection</I> is an integral part of Java and its run-time system. While Java has a <CODE>new</CODE> operator to allocate memory for objects, there is no explicit <CODE>free</CODE> function. Once you have allocated an object, the run-time system keeps track of the object's status and automatically reclaims memory when objects are no longer in use, freeing memory for future use. <P>
Java's memory management model is based on <I>objects</I> and references to objects. Because Java has no pointers, all references to allocated storage, which in practice means all references to an object, are through symbolic "handles". The Java memory manager keeps track of references to objects. When an object has no more references, the object is a candidate for garbage collection.<P>
Java's memory allocation model and automatic garbage collection make your programming task easier, eliminate entire classes of bugs, and in general provide better performance than you'd obtain through explicit memory management. Here's a code fragment that illustrates when garbage collection happens. It's an example from the on-line Java language programmer's guide:<P>
<PRE>
class ReverseString {
    public static String reverseIt(String source) {
        int i, len = source.length();
        StringBuffer dest = new StringBuffer(len);

        for (i = (len - 1); i &gt;= 0; i--) {
            dest.appendChar(source.charAt(i));
        }
        return dest.toString();
    }
}
</PRE>
The variable <CODE>dest</CODE> is used as a temporary object reference during the execution of the <CODE>reverseIt</CODE> method. When <CODE>dest</CODE> goes out of scope (the <CODE>reverseIt</CODE> method returns), the reference to that object has gone away and it's then a candidate for garbage collection.<P>
<H3> 2.1.7 The Background Garbage Collector</H3>
The Java garbage collector achieves high performance by taking advantage of the nature of a user's behavior when interacting with software applications such as the HotJava browser. The typical user of the typical interactive application has many natural pauses where they're contemplating the scene in front of them or thinking of what to do next. The Java run-time system takes advantage of these idle periods and runs the garbage collector in a low priority thread when no other threads are competing for CPU cycles. The garbage collector gathers and compacts unused memory, increasing the probability that adequate memory resources are available when needed during periods of heavy interactive use. <P>
This use of a thread to run the garbage collector is just one of many examples of the synergy one obtains from Java's integrated multithreading capabilities--an otherwise intractable problem is solved in a simple and elegant fashion.<P>
<H3> 2.1.8 Integrated Thread Synchronization</H3>
Java supports multithreading, both at the language (syntactic) level and via support from its run-time system and thread objects. While other systems have provided facilities for multithreading (usually via "lightweight process" libraries), building multithreading support into the language itself provides the programmer with a much easier and more powerful tool for easily creating thread-safe multithreaded classes. Multithreading is discussed in more detail in Chapter 5.<P>
<A NAME=HEADING4-71></A>
<HR>
<H2> 2.2 Features Removed from C and C++</H2>
The earlier part of this chapter concentrated on the principal features of Java. This section discusses features removed from C and C++ in the evolution of Java. <P>
The first step was to <I>eliminate redundancy</I> from C and C++. In many ways, the C language evolved into a collection of overlapping features, providing too many ways to say the same thing, while in many cases not providing needed features. C++, in an attempt to add "classes in C", merely added more redundancy while retaining many of the inherent problems of C.<P>
<H3> 2.2.1 No More Typedefs, Defines, or Preprocessor</H3>
Source code written in Java is <I>simple</I>. There is no <I>preprocessor</I>, no <CODE>#define</CODE> and related capabilities, no <CODE>typedef</CODE>, and absent those features, no longer any need for <I>header files</I>. Instead of header files, Java language source files provide the definitions of other classes and their methods. <P>
A major problem with C and C++ is the amount of context you need to understand another programmer's code: you have to read all related header files, all related <CODE>#define</CODE>s, and all related <CODE>typedef</CODE>s before you can even begin to analyze a program. In essence, programming with <CODE>#defines</CODE> and <CODE>typedef</CODE>s results in every programmer inventing a new programming language that's incomprehensible to anybody other than its creator, thus defeating the goals of good programming practices.<P>
In Java, you obtain the effects of <CODE>#define</CODE> by using constants. You obtain the effects of <CODE>typedef</CODE> by declaring classes--after all, a class effectively declares a new type. You don't need header files because the Java compiler compiles class definitions into a binary form that retains all the type information through to link time. <P>
By removing all this baggage, Java becomes remarkably <I>context-free</I>. Programmers can read and understand code and, more importantly, modify and reuse code much faster and easier. <P>
<H3> 2.2.2 No More Structures or Unions</H3>
Java has no structures or unions as complex data types. You don't need structures and unions when you have classes; you can achieve the same effect simply by declaring a class with the appropriate instance variables. <P>
The code fragment below declares a class called <CODE>Point</CODE>. <P>
<PRE>
    class Point extends Object { 
        double  x;
        double  y;
          <I>methods to access the instance variables
</I>    }
</PRE>
The following code fragment declares a class called <CODE>Rectangle</CODE>, that uses objects of the <CODE>Point</CODE> class as instance variables.<P>
<PRE>
    class Rectangle extends Object {
        Point  lowerLeft;
        Point  upperRight;
          <I>methods to access the instance variables
</I>    }
</PRE>
In C you'd define these classes as structures. In Java, you simply declare classes. You can make the instance variables as private or as public as you wish, depending on how much you wish to hide the details of the implementation from other objects. <P>
<PRE>

</PRE>
<H3> 2.2.3 No More Functions</H3>
Java has no <I>functions</I>. Object-oriented programming supersedes functional and procedural styles. Mixing the two styles just leads to confusion and dilutes the purity of an object-oriented language. Anything you can do with a function you can do just as well by defining a class and creating methods for that class. Consider the <CODE>Point</CODE> class from above. We've added public methods to set and access the instance variables:<P>
<PRE>
    class Point extends Object { 
        double  x;
        double  y;
        
        public void setX(double x) {
            this.x = x;
        }
        public void setY(double y) {
            this.y = y;
        }
        public double x() {
            return x;
        }
        public double y() {
            return x;
        }
    }
</PRE>
If the <CODE>x</CODE> and <CODE>y</CODE> instance variables are private to this class, the only means to access them is via the public methods of the class. Here's how you'd use objects of the <CODE>Point</CODE> class from within, say, an object of the <CODE>Rectangle</CODE> class:<P>
<PRE>
    class Rectangle extends Object { 
        Point  lowerLeft;
        Point  upperRight;
        
        public void setEmptyRect() {
            lowerLeft.setX(0.0);
            lowerLeft.setY(0.0);
            upperRight.setX(0.0);
            upperRight.setY(0.0);
        }
    }
</PRE>
It's not to say that functions and procedures are inherently wrong. But given classes and methods, we're now down to only one way to express a given task. By eliminating functions, your job as a programmer is immensely simplified: you work <I>only</I> with classes and their methods.<P>
<H3> 2.2.4 No More Multiple Inheritance</H3>
<I>Multiple inheritance</I>--and all the problems it generates--has beed discarded from Java. The desirable features of multiple inheritance are provided by <I>interfaces</I>--conceptually similar to Objective C protocols.<P>
An interface is not a definition of an object. Rather, it's a definition of a set of methods that one or more objects will implement. An important issue of interfaces is that they declare only methods and constants. No variables may be defined in interfaces.<P>
<H3> 2.2.5 No More Goto Statements </H3>
Java has no <CODE>goto</CODE> statement<A HREF="#FOOTNOTE-2">[2]</A>. Studies illustrated that <CODE>goto</CODE> is (mis)used more often than not simply "because it's there". Eliminating <CODE>goto</CODE> led to a simplification of the language--there are no rules about the effects of a <CODE>goto</CODE> into the middle of a <CODE>for</CODE> statement, for example. Studies on approximately 100,000 lines of C code determined that roughly 90 percent of the <CODE>goto</CODE> statements were used purely to obtain the effect of breaking out of nested loops. As mentioned above, multi-level <CODE>break</CODE> and <CODE>continue</CODE> remove most of the need for <CODE>goto</CODE> statements.<P>
<H3> 2.2.6 No More Operator Overloading</H3>
There are no means provided by which programmers can overload the standard arithmetic operators. Once again, the effects of operator overloading can be just as easily achieved by declaring a class, appropriate instance variables, and appropriate methods to manipulate those variables. <P>
<H3> 2.2.7 No More Automatic Coercions</H3>
Java prohibits C and C++ style <I>automatic coercions. </I>If you wish to coerce a data element of one type to a data type that would result in loss of precision, you must do so explicitly by using a cast. Consider this code fragment:<P>
<PRE>

    int  myInt;
    double  myFloat = 3.14159;
    myInt = myFloat;
</PRE>
The assignment of <CODE>myFloat</CODE> to <CODE>myInt</CODE> would result in a compiler error indicating a possible loss of precision and that you must use an explicit cast. Thus, you should re-write the code fragments as:<P>
<PRE>
    int  myInt;
    double  myFloat = 3.14159;
    myInt = (int)myFloat;

</PRE>
<H3> 2.2.8 No More Pointers</H3>
Most studies agree that <I>pointers</I> are one of the primary features that enable programmers to inject bugs into their code. Given that structures are gone, and arrays and strings are objects, the need for pointers to these constructs goes away. Thus, Java has no pointers. Any task that would require arrays, structures, and pointers in C can be more easily and reliably performed by declaring objects and arrays of objects. Instead of complex pointer manipulation on array pointers, you access arrays by their arithmetic indices. The Java run-time system checks all array indexing to ensure indices are within the bounds of the array. <P>
You no longer have dangling pointers and trashing of memory because of incorrect pointers, because there are no pointers in Java.<P>
<A NAME=HEADING4-112></A>
<HR>
<H2> 2.3 Summary</H2>
To sum up this chapter, Java is:<P>
<UL>
<LI><I>Simple</I>--the number of language constructs you need to understand to get your job done is minimal.<P>
<LI><I>Familiar</I>--Java looks like C and C++ while discarding the overwhelming complexities of those languages.<P>
</UL>
Now that you've seen how Java was simplified by removal of features from its predecessors, read the next chapter for a discussion on the <I>object-oriented</I> features of Java.<P>
<P>
<HR>

<A NAME="FOOTNOTE-1">[1] Now enjoying their silver anniversaries
<HR>

<A NAME="FOOTNOTE-2">[2] However, <CODE>goto</CODE> is still a reserved word.
<HR>
<A HREF="java-whitepaper-5.html">Next</A>       <A HREF="java-whitepaper-3.html">Prev</A>              <A HREF="java-whitepaper-1.html">Contents</A><P>
<B>The Java(tm) Language Environment: A White Paper</B><P>
</BODY>
</HTML> 