<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 --> <HTML> <HEAD>
<TITLE>The Java(tm) White Paper: Multithreading in Java</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING9></A>
<A HREF="java-whitepaper-10.html">Next</A>       <A HREF="java-whitepaper-8.html">Prev</A>              <A HREF="java-whitepaper-1.html">Contents</A><P>
<HR>
<H1>Multithreading in Java</H1>
<DL>
<DT><A HREF="java-whitepaper-9.html#HEADING9-5"><B>	7.1	</B> - Threads at the Java Language Level</A><DD>
<DT><A HREF="java-whitepaper-9.html#HEADING9-10"><B>	7.2	</B> - Integrated Thread Synchronization</A><DD>
<DT><A HREF="java-whitepaper-9.html#HEADING9-17"><B>	7.3	</B> - Multithreading Support--Conclusion</A><DD>
</DL>

<HR>
<A NAME=HEADING9-0></A>


Sophisticated computer users become impatient with the do-one-thing-at-a-time mindset of the average personal computer. Users perceive that their world is full of multiple events all happening at once, and they like to have their computers work the same way.<P>
Unfortunately, writing programs that deal with many things happening at once can be <I>much</I> more difficult than writing in the conventional single-threaded C and C++ style. You can write multithreaded applications in languages such as C and C++, but the level of difficulty goes up by orders of magnitude, and even then there are no assurances that vendors' libraries are thread-safe.<P>
The term <I>thread-safe</I> means that a given library function is implemented in such a manner that it can be executed by multiple concurrent threads of execution. <P>
The major problem with explicitly programmed thread support is that you can never be quite sure you have acquired the locks you need and released them again at the right time. If you return from a method prematurely, for instance, or if an exception is raised, for another instance, your lock has not been released; deadlock is the usual result.<P>
<A NAME=HEADING9-6></A>
<HR>
<H2> 7.1 Threads at the Java Language Level</H2>
Built-in support for threads provides Java programmers with a powerful tool to improve interactive performance of graphical applications. If your application needs to run animations and play music while scrolling the page and downloading a text file from a server, multithreading is the way to obtain fast, lightweight concurrency within a single process space. Threads are sometimes also called lightweight processes or execution contexts. <P>
Threads are an essential keystone of Java. The Java library provides a <CODE>Thread</CODE> class that supports a rich collection of methods to start a thread, run a thread, stop a thread, and check on a thread's status.<P>
Java thread support includes a sophisticated set of <I>synchronization primitives</I> based on the widely used <I>monitor</I> and <I>condition variable</I> paradigm introduced twenty years ago by C.A.R. Hoare and implemented in a production setting in Xerox PARC's Cedar/Mesa system. Integrating support for threads into the language makes them much easier to use and more robust. Much of the style of Java's integration of threads was modelled after Cedar and Mesa.<P>
Java's threads are <I>pre-emptive</I>, and depending on platform on which the Java interpreter executes, threads can also be <I>time-sliced</I>. On systems that don't support time-slicing, once a thread has started, the only way it will relinquish control of the processor is if another thread of a higher priority takes control of the processor. If your applications are likely to be compute-intensive, you might consider how to give up control periodically by using the <CODE>yield()</CODE> method to give other threads a chance to run; doing so will ensure better interactive response for graphical applications.<P>
<A NAME=HEADING9-11></A>
<HR>
<H2> 7.2 Integrated Thread Synchronization</H2>
Java supports multithreading at the language (syntactic) level and via support from its run-time system and thread objects. At the language level, methods within a class that are declared <CODE>synchronized</CODE> do not run concurrently. Such methods run under control of <I>monitors</I> to ensure that variables remain in a consistent state. Every class and instantiated object has its own monitor that comes into play if required.<P>
Here are a couple of code fragments from the sorting demonstration in the HotJava web browser. The main points of interest are the two methods <CODE>stop</CODE> and <CODE>startSort</CODE>, which share a common variable called <CODE>kicker</CODE> (it kicks off the sort thread):<P>
<PRE>
public synchronized void stop() {
    if (kicker != null) {
        kicker.stop();
        kicker = null;
    }
}
private synchronized void startSort() { 
    if (kicker == null || !kicker.isAlive()) {
        kicker = new Thread(this);
        kicker.start();
    }
}
</PRE>
The <CODE>stop</CODE> and <CODE>startSort</CODE> methods are declared to be <CODE>synchronized</CODE>--they can't run concurrently, enabling them to maintain consistent state in the shared <CODE>kicker</CODE> variable. When a <CODE>synchronized</CODE> method is entered, it acquires a monitor on the current object. The monitor precludes any other <CODE>synchronized</CODE> methods in that object from running. When a <CODE>synchronized</CODE> method returns by any means, its monitor is released. Other <CODE>synchronized</CODE> methods within the same object are now free to run.<P>
If you're writing Java applications, you should take care to implement your classes and methods so they're thread-safe, in the same way that Java run-time libraries are thread-safe. If you wish your objects to be thread-safe, any methods that may change the values of instance variables should be declared <CODE>synchronized</CODE>. This ensures that only one method can change the state of an object at any time. Java monitors are <I>re-entrant</I>: a method can acquire the same monitor more than once, and everything will still work.<P>
<A NAME=HEADING9-18></A>
<HR>
<H2> 7.3 Multithreading Support--Conclusion</H2>
While other systems have provided facilities for multithreading (usually via "lightweight process" libraries), building multithreading support into the language as Java has done provides the programmer with a much more powerful tool for easily creating thread-safe multithreaded classes.<P>
Other benefits of multithreading are better interactive responsiveness and real-time behavior. Stand-alone Java run-time environments exhibit good real-time behavior. Java environments running on top of popular operating systems provide the real-time responsiveness available from the underlying platform.<P>
<P>
<HR>
<A HREF="java-whitepaper-10.html">Next</A>       <A HREF="java-whitepaper-8.html">Prev</A>              <A HREF="java-whitepaper-1.html">Contents</A><P>
<B>The Java(tm) Language Environment: A White Paper</B><P>
</BODY>
</HTML> 