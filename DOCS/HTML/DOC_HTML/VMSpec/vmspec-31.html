<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 --> <HTML> <HEAD>
<TITLE>vmspec: An Optimization</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING31></A>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-30.html">Prev</A>       <A HREF="vmspec-32.html">Next</A>              <P>
<HR>
<A NAME=HEADING31-0></A>
<H1>Appendix A:  An Optimization</H1>
<HR>
The following set of pseudo-instructions suffixed by <CODE>_quick</CODE> are variants of Java virtual machine instructions. They are used to improve the speed of interpreting bytecodes. They are not part of the virtual machine specification or instruction set, and are invisible outside of an Java virtual machine implementation. However, inside a virtual machine implementation they have proven to be an effective optimization.<P>
A compiler from Java source code to the Java virtual machine instruction set emits only non-<CODE>_quick</CODE> instructions. If the <CODE>_quick</CODE> pseudo-instructions are used, each instance of a non-<CODE>_quick</CODE> instruction with a <CODE>_quick</CODE> variant is overwritten on execution by its <CODE>_quick</CODE> variant. Subsequent execution of that instruction instance will be of the <CODE>_quick</CODE> variant.<P>
In all cases, if an instruction has an alternative version with the suffix <CODE>_quick</CODE>, the instruction references the constant pool. If the <CODE>_quick</CODE> optimization is used, each non-<CODE>_quick</CODE> instruction with a <CODE>_quick</CODE> variant performs the following:<P>
<UL>
<LI>Resolves the specified item in the constant pool<P>
<LI>Signals an error if the item in the constant pool could not be resolved for some reason<P>
<LI>Turns itself into the <CODE>_quick</CODE> version of the instruction. The instructions <CODE>putstatic</CODE>, <CODE>getstatic</CODE>, <CODE>putfield</CODE>, and <CODE>getfield</CODE> each have two <CODE>_quick</CODE> versions.<P>
<LI>Performs its intended operation<P>
</UL>
This is identical to the action of the instruction without the <CODE>_quick</CODE> optimization, except for the additional step in which the instruction overwrites itself with its <CODE>_quick</CODE> variant. <P>
The <CODE>_quick</CODE> variant of an instruction assumes that the item in the constant pool has already been resolved, and that this resolution did not generate any errors. It simply performs the intended operation on the resolved item.<P>
Note: some of the invoke methods only support a single-byte offset into the method table of the object; for objects with 256 or more methods some invocations cannot be "quicked" with only these bytecodes. We also need to define or change existing <CODE>getfield</CODE> and <CODE>putfield</CODE> bytecodes to support more than a byte of offset.<P>
This Appendix doesn't give the opcode values of the pseudo-instructions, since they are invisible and subject to change.<P>
<HR>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-30.html">Prev</A>       <A HREF="vmspec-32.html">Next</A>              <P>
</BODY>
</HTML> 