<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 --> <HTML> <HEAD>
<TITLE>vmspec: Control Transfer Instructions</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING23></A>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-22.html">Prev</A>       <A HREF="vmspec-24.html">Next</A>       <A HREF="vmspec-12.html">Up</A>       <P>
<HR>
<A NAME=HEADING23-0></A>
<H2>3.11 Control Transfer Instructions</H2>
<H3><A NAME=MARKER-9-306></A><A NAME=MARKER-8-307></A><A NAME=MARKER-8-308></A>ifeq</H3>
Branch if equal
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>ifeq = 153<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
 to 0<P>
<PRE>
Stack: ..., value =&gt; ...<P>
</PRE>
value must be an integer. It is popped from the stack. If value is zero, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>ifeq</CODE>.<P>
<H3>ifnull</H3>
Branch if null
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>ifnull = 198<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
<P>
<PRE>
Stack: ..., value =&gt; ...<P>
</PRE>
value must be a reference to an object. It is popped from the stack. If value is <CODE>null</CODE>, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>ifnull<I>.</I></CODE><P>
<H3><A NAME=MARKER-9-309></A><A NAME=MARKER-8-310></A><A NAME=MARKER-8-311></A>iflt</H3>
Branch if less than
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>iflt = 155<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
 0<P>
<PRE>
Stack: ..., value =&gt; ...<P>
</PRE>
value must be an integer. It is popped from the stack. If value is less than zero, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>iflt</CODE>. <P>
<H3><A NAME=MARKER-9-312></A><A NAME=MARKER-8-313></A><A NAME=MARKER-8-314></A>ifle</H3>
Branch if less than or equal
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>ifle = 158<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
 to 0<P>
<PRE>
Stack: ..., value =&gt; ...<P>
</PRE>
value must be an integer. It is popped from the stack. If value is less than or equal to zero, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>ifle</CODE>. <P>
<H3><A NAME=MARKER-9-315></A><A NAME=MARKER-8-316></A><A NAME=MARKER-8-317></A>ifne</H3>
Branch if not equal
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>ifne = 154<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
 to 0<P>
<PRE>
Stack: ..., value =&gt; ...<P>
</PRE>
value must be an integer. It is popped from the stack. If value is not equal to zero, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>ifne</CODE>.<P>
<H3>ifnonnull</H3>
Branch if not null
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>ifnonnull = 199<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
<P>
<PRE>
Stack: ..., value =&gt; ...<P>
</PRE>
value must be a reference to an object. It is popped from the stack. If value is not <CODE>null</CODE>, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>ifnonnull.</CODE><P>
<H3><A NAME=MARKER-9-318></A><A NAME=MARKER-8-319></A><A NAME=MARKER-8-320></A>ifgt</H3>
Branch if greater than
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>ifgt = 157<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
 0<P>
<PRE>
Stack: ..., value =&gt; ...<P>
</PRE>
value must be an integer. It is popped from the stack. If value is greater than zero, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>ifgt</CODE>.<P>
<H3><A NAME=MARKER-9-321></A><A NAME=MARKER-8-322></A><A NAME=MARKER-8-323></A>ifge</H3>
Branch if greater than or equal
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>ifge = 156<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
 to 0<P>
<PRE>
Stack: ..., value =&gt; ...<P>
</PRE>
value must be an integer. It is popped from the stack. If value is greater than or equal to zero, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>ifge</CODE>.<P>
<H3><A NAME=MARKER-9-324></A><A NAME=MARKER-8-325></A><A NAME=MARKER-8-326></A>if_icmpeq</H3>
Branch if integers equal
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>if_icmpeq = 159<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
<P>
<PRE>
Stack: ..., value1, value2 =&gt; ...<P>
</PRE>
value1 and value2 must be integers. They are both popped from the stack. If <I>value1 </I>is equal to <I>value2</I>, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>if_icmpeq</CODE>. <P>
<H3><A NAME=MARKER-9-327></A><A NAME=MARKER-8-328></A><A NAME=MARKER-8-329></A>if_icmpne</H3>
Branch if integers not equal
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>if_icmpne = 160<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
<P>
<PRE>
Stack: ..., value1, value2 =&gt; ...<P>
</PRE>
value1 and value2 must be integers. They are both popped from the stack. If <I>value1 </I>is not equal to <I>value2</I>, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>if_icmpne</CODE>.<P>
<H3><A NAME=MARKER-9-330></A><A NAME=MARKER-8-331></A><A NAME=MARKER-8-332></A>if_icmplt</H3>
Branch if integer less than
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>if_icmplt = 161<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
<P>
<PRE>
Stack: ..., value1, value2 =&gt; ...<P>
</PRE>
value1 and value2 must be integers. They are both popped from the stack. If <I>value1 </I>is less than <I>value2</I>, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>if_icmplt</CODE>. <P>
<H3><A NAME=MARKER-9-333></A><A NAME=MARKER-8-334></A><A NAME=MARKER-8-335></A>if_icmpgt</H3>
Branch if integer greater than
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>if_icmpgt = 163<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
<P>
<PRE>
Stack: ..., value1, value2 =&gt; ...<P>
</PRE>
value1 and value2 must be integers. They are both popped from the stack. If <I>value1 </I>is greater than <I>value2</I>,<I> branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>if_icmpgt</CODE>. <P>
<H3><A NAME=MARKER-9-336></A><A NAME=MARKER-8-337></A><A NAME=MARKER-8-338></A>if_icmple</H3>
Branch if integer less than or equal to
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>if_icmple = 164<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
<P>
<PRE>
Stack: ..., value1, value2 =&gt; ...<P>
</PRE>
value1 and value2 must be integers. They are both popped from the stack. If value1 is less than or equal to <I>value2</I>, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>if_icmple</CODE>.<P>
<H3><A NAME=MARKER-9-339></A><A NAME=MARKER-8-340></A><A NAME=MARKER-8-341></A>if_icmpge</H3>
Branch if integer greater than or equal to
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>if_icmpge = 162<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
<P>
<PRE>
Stack: ..., value1, value2 =&gt; ...<P>
</PRE>
value1 and value2 must be integers. They are both popped from the stack. If <I>value1 </I>is greater than or equal to <I>value2</I>, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>if_icmpge</CODE>.<P>
<H3><A NAME=MARKER-9-342></A><A NAME=MARKER-8-343></A><A NAME=MARKER-8-344></A>lcmp</H3>
Long integer compare
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>lcmp = 148</TABLE>
<P>
<PRE>
Stack: ..., value1<CODE>-word1</CODE>, value1<CODE>-word2</CODE>, value2<CODE>-word1</CODE>, value2<CODE>-word1</CODE> =&gt; ..., result<P>
</PRE>
value1 and value2 must be long integers. They are both popped from the stack and compared. If value1 is greater than value2, the integer value 1 is pushed onto the stack. If value1 is equal to value2, the value 0 is pushed onto the stack. If value1 is less than value2, the value -1 is pushed onto the stack.<P>
<H3><A NAME=MARKER-9-345></A><A NAME=MARKER-8-346></A><A NAME=MARKER-8-347></A>fcmpl</H3>
Single float compare (-1 on NaN
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>fcmpl = 149</TABLE>
)<P>
<PRE>
Stack: ..., value1, value2 =&gt; ..., result<P>
</PRE>
value1 and value2 must be single-precision floating point numbers. They are both popped from the stack and compared. If value1 is greater than value2, the integer value 1 is pushed onto the stack. If value1 is equal to value2, the value 0 is pushed onto the stack. If value1 is less than value2, the value -1 is pushed onto the stack.<P>
If either value1 or value2 is NaN, the value -1 is pushed onto the stack.<P>
<H3><A NAME=MARKER-9-348></A><A NAME=MARKER-8-349></A><A NAME=MARKER-8-350></A>fcmpg</H3>
Single float compare (1 on NaN
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>fcmpg = 150</TABLE>
)<P>
<PRE>
Stack: ..., value1, value2 =&gt; ..., result<P>
</PRE>
value1 and value2 must be single-precision floating point numbers. They are both popped from the stack and compared. If value1 is greater than value2, the integer value 1 is pushed onto the stack. If value1 is equal to value2, the value 0 is pushed onto the stack. If value1 is less than value2, the value -1 is pushed onto the stack.<P>
If either value1 or value2 is NaN, the value 1 is pushed onto the stack.<P>
<H3><A NAME=MARKER-9-351></A><A NAME=MARKER-8-352></A><A NAME=MARKER-8-353></A>dcmpl</H3>
Double float compare (-1 on NaN
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>dcmpl = 151</TABLE>
)<P>
<PRE>
Stack: ..., value1<CODE>-word1</CODE>, value1<CODE>-word2</CODE>, value2<CODE>-word1</CODE>, value2<CODE>-word1</CODE> =&gt; ..., result<P>
</PRE>
value1 and value2 must be double-precision floating point numbers. They are both popped from the stack and compared. If value1 is greater than value2, the integer value 1 is pushed onto the stack. If value1 is equal to value2, the value 0 is pushed onto the stack. If value1 is less than value2, the value -1 is pushed onto the stack.<P>
If either value1 or value2 is NaN, the value -1 is pushed onto the stack.<P>
<H3><A NAME=MARKER-9-354></A><A NAME=MARKER-8-355></A><A NAME=MARKER-8-356></A>dcmpg</H3>
Double float compare (1 on NaN
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>dcmpg = 152</TABLE>
)<P>
<PRE>
Stack: ..., value1<CODE>-word1</CODE>, value1<CODE>-word2</CODE>, value2<CODE>-word1</CODE>, value2<CODE>-word1</CODE> =&gt; ..., result<P>
</PRE>
value1 and value2 must be double-precision floating point numbers. They are both popped from the stack and compared. If value1 is greater than value2, the integer value 1 is pushed onto the stack. If value1 is equal to value2, the value 0 is pushed onto the stack. If value1 is less than value2, the value -1 is pushed onto the stack.<P>
If either value1 or value2 is NaN, the value 1 is pushed onto the stack.<P>
<H3><A NAME=MARKER-9-357></A><A NAME=MARKER-8-358></A><A NAME=MARKER-8-359></A>if_acmpeq</H3>
Branch if object references are equal
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>if_acmpeq = 165<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
<P>
<PRE>
Stack: ..., value1, value2 =&gt; ...<P>
</PRE>
value1 and value2 must be references to objects. They are both popped from the stack. If <I>the objects refrerenced are not the same</I>, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the Address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>if_acmpeq.</CODE><P>
<H3><A NAME=MARKER-9-360></A><A NAME=MARKER-8-361></A><A NAME=MARKER-8-362></A>if_acmpne</H3>
Branch if object references not equal
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>if_acmpne = 166<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
<P>
<PRE>
Stack: ..., value1, value2 =&gt; ...<P>
</PRE>
value1 and value2 must be references to objects. They are both popped from the stack. If the objecs referenced are not the same, <I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction. Otherwise execution proceeds at the instruction following the <CODE>if_acmpne</CODE>.<P>
<H3><A NAME=MARKER-9-363></A><A NAME=MARKER-8-364></A><A NAME=MARKER-8-365></A>goto</H3>
Branch 
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>goto = 167<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
always<P>
<PRE>
Stack: no change<P>
</PRE>
<I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. Execution proceeds at that offset from the address of this instruction.<P>
<H3>goto_w</H3>
Branch always (wide index)
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>goto_w = 200<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2<TR>
<TD>branchbyte3<TR>
<TD>branchbyte4</TABLE>
<P>
<PRE>
Stack: no change<P>
</PRE>
<I>branchbyte1</I>, <I>branchbyte2</I>, <I>branchbyte3</I>, and <I>branchbyte4</I> are used to construct a signed 32-bit offset. Execution proceeds at that offset from the address of this instruction.<P>
<H3><A NAME=MARKER-9-366></A><A NAME=MARKER-8-367></A><A NAME=MARKER-8-368></A>jsr</H3>
Jump subroutine
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>jsr = 168<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2</TABLE>
<P>
<PRE>
Stack: ... =&gt; ..., return-address<P>
</PRE>
<I>branchbyte1 </I>and <I>branchbyte2 </I>are used to construct a signed 16-bit offset. The address of the instruction immediately following the <CODE>jsr</CODE> is pushed onto the stack. Execution proceeds at the offset from the address of this instruction.<P>
Note: The <CODE>jsr</CODE> instruction is used in the implementation of Java's <CODE>finally</CODE> keyword.<P>
<H3>jsr_w</H3>
Jump subroutine (wide index)
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>jsr_w = 201<TR>
<TD>branchbyte1<TR>
<TD>branchbyte2<TR>
<TD>branchbyte3<TR>
<TD>branchbyte4</TABLE>
<P>
<PRE>
Stack: ... =&gt; ..., return-address<P>
</PRE>
<I>branchbyte1</I>, <I>branchbyte2</I>, <I>branchbyte3</I>, and <I>branchbyte4</I> are used to construct a signed 32-bit offset. The address of the instruction immediately following the <CODE>jsr_w</CODE> is pushed onto the stack. Execution proceeds at the offset from the address of this instruction.<P>
<H3><A NAME=MARKER-9-369></A><A NAME=MARKER-8-370></A><A NAME=MARKER-8-371></A>ret</H3>
Return from subroutine
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>ret = 169<TR>
<TD>vindex</TABLE>
<P>
<PRE>
Stack: no change<P>
</PRE>
<I>Local variable vindex in the current Java frame must contain a return address. </I>The contents of the local variable are written into the pc.<P>
Note that <CODE>jsr</CODE> pushes the address onto the stack, and <CODE>ret</CODE> gets it out of a local variable. This asymmetry is intentional.<P>
Note: The <CODE>ret</CODE> instruction is used in the implementation of Java's <CODE>finally<EM> </EM></CODE>keyword.<P>
<H3>ret_w</H3>
Return from subroutine (wide index)
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD><CODE>ret_w</CODE> = 209<TR>
<TD>vindexbyte1<TR>
<TD>vindexbyte2</TABLE>
<P>
<PRE>
Stack: no change<P>
</PRE>
vindexbyte1 and vindexbyte2 are assembled into an unsigned 16-bit index to a local variable in the current Java frame. That local variable must contain a return address.<I> </I>The contents of the local variable are written into the pc. See the <CODE>ret</CODE> instruction for more information.<P>
<HR>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-22.html">Prev</A>       <A HREF="vmspec-24.html">Next</A>       <A HREF="vmspec-12.html">Up</A>       <P>
</BODY>
</HTML> 