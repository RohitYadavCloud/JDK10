<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 --> <HTML> <HEAD>
<TITLE>vmspec: Method Invocation</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING27></A>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-26.html">Prev</A>       <A HREF="vmspec-28.html">Next</A>       <A HREF="vmspec-12.html">Up</A>       <P>
<HR>
<A NAME=HEADING27-0></A>
<H2>3.15 Method Invocation</H2>
There are four instructions that implement method invocation.<P>
<DL>
<DT><CODE>invokevirtual</CODE>
<DD> Invoke an instance method of an object, dispatching based on the runtime (virtual) type of the object. This is the normal method dispatch in Java.
<DT>
<DD>
<DT><CODE>invokenonvirtual</CODE>
<DD> Invoke an instance method of an object, dispatching based on the compile-time (non-virtual) type of the object. This is used, for example, when the keyword <CODE>super</CODE> or the name of a superclass is used as a method qualifier.
<DT>
<DD>
<DT><CODE>invokestatic</CODE>
<DD> Invoke a class (<CODE>static</CODE>) method in a named class. 
<DT>
<DD>
<DT><CODE>invokeinterface</CODE> 
<DD> Invoke a method which is implemented by an interface, searching the methods implemented by the particular run-time object to find the appropriate method.
</DL>
<H3><A NAME=MARKER-9-411></A><A NAME=MARKER-8-412></A><A NAME=MARKER-8-413></A>invokevirtual</H3>
Invoke instance method
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>invokevirtual = 182<TR>
<TD>indexbyte1<TR>
<TD>indexbyte2</TABLE>
, dispatch based on run-time type<P>
<PRE>
Stack: <I>..., objectref, [arg1, [arg2 ...]], ... </I>=&gt;<I> ...</I><P>
</PRE>
The operand stack must contain a reference to an object and some number of arguments. indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index in the constant pool contains the complete method signature. A pointer to the object's method table is retrieved from the object reference. The method signature is looked up in the method table. The method signature is guaranteed to exactly match one of the method signatures in the table. <P>
The result of the lookup is an index into the method table of the named class, which is used with the object's dynamic type to look in the method table of that type, where a pointer to the method block for the matched method is found. The method block indicates the type of method (<CODE>native</CODE>, <CODE>synchronized</CODE>, and so on) and the number of arguments expected on the operand stack.<P>
If the method is marked <CODE>synchronized</CODE> the monitor associated with objectref is entered.<P>
The objectref and arguments are popped off this method's stack and become the initial values of the local variables of the new method. Execution continues with the first instruction of the new method.<P>
If the object reference on the operand stack is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. If during the method invocation a stack overflow is detected, a <CODE>StackOverflowError</CODE> is thrown. <P>
<H3><A NAME=MARKER-9-414></A><A NAME=MARKER-8-415></A><A NAME=MARKER-8-416></A>invokenonvirtual</H3>
Invoke instance method, dispatching based on compile-time type
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>invokenonvirtual = 183<TR>
<TD>indexbyte1<TR>
<TD>indexbyte2</TABLE>
<P>
<PRE>
Stack: <I>..., objectref, [arg1, [arg2 ...]], ... </I>=&gt;<I> ...</I><P>
</PRE>
The operand stack must contain a reference to an object and some number of arguments. indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index in the constant pool contains a complete method signature and class. The method signature is looked up in the method table of the class indicated. The method signature is guaranteed to exactly match one of the method signatures in the table. <P>
The result of the lookup is a method block. The method block indicates the type of method (<CODE>native</CODE>, <CODE>synchronized</CODE>, and so on) and the number of arguments (nargs) expected on the operand stack.<P>
If the method is marked <CODE>synchronized</CODE> the monitor associated with objectref is entered.<P>
The objectref and arguments are popped off this method's stack and become the initial values of the local variables of the new method. Execution continues with the first instruction of the new method.<P>
If the object reference on the operand stack is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. If during the method invocation a stack overflow is detected, a <CODE>StackOverflowError</CODE> is thrown. <P>
<H3>invokestatic</H3>
Invoke a class (static) method
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>invokestatic = 184<TR>
<TD>indexbyte1<TR>
<TD>indexbyte2</TABLE>
<P>
<PRE>
Stack: <I>..., [arg1, [arg2 ...]], ... </I>=&gt;<I> ...</I><P>
</PRE>
The operand stack must contain some number of arguments. indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current class. The item at that index in the constant pool contains the complete method signature and class. The method signature is looked up in the method table of the class indicated. The method signature is guaranteed to exactly match one of the method signatures in the class's method table. <P>
The result of the lookup is a method block. The method block indicates the type of method (<CODE>native</CODE>, <CODE>synchronized</CODE>, and so on) and the number of arguments (nargs) expected on the operand stack.<P>
If the method is marked <CODE>synchronized</CODE> the monitor associated with the class is entered.<P>
The arguments are popped off this method's stack and become the initial values of the local variables of the new method. Execution continues with the first instruction of the new method.<P>
If during the method invocation a stack overflow is detected, a <CODE>StackOverflowError</CODE> is thrown. <P>
<H3><A NAME=MARKER-9-417></A><A NAME=MARKER-8-418></A><A NAME=MARKER-8-419></A><A NAME=MARKER-9-420></A><A NAME=MARKER-8-421></A><A NAME=MARKER-8-422></A>invokeinterface</H3>
Invoke interface method
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>invokeinterface = 185<TR>
<TD>indexbyte1<TR>
<TD>indexbyte2<TR>
<TD>nargs<TR>
<TD>reserved</TABLE>
<P>
<PRE>
Stack: <I>..., objectref, [arg1, [arg2 ...]], ... </I>=&gt; <I>...</I><P>
</PRE>
The operand stack must contain a reference to an object and <I>nargs</I>-1 arguments. <I>indexbyte1</I> and <I>indexbyte2</I> are used to construct an index into the constant pool of the current class. The item at that index in the constant pool contains the complete method signature. A pointer to the object's method table is retrieved from the object reference. The method signature is looked up in the method table. The method signature is guaranteed to exactly match one of the method signatures in the table. <P>
The result of the lookup is a method block. The method block indicates the type of method (<CODE>native</CODE>, <CODE>synchronized</CODE>, and so on) but unlike <CODE>invokevirtual</CODE> and <CODE>invokenonvirtual</CODE>, the number of available arguments (nargs) is taken from the bytecode. <P>
If the method is marked <CODE>synchronized</CODE> the monitor associated with objectref is entered.<P>
The objectref and arguments are popped off this method's stack and become the initial values of the local variables of the new method. Execution continues with the first instruction of the new method.<P>
If the objectref on the operand stack is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. If during the method invocation a stack overflow is detected, a <CODE>StackOverflowError</CODE> is thrown. <P>
<HR>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-26.html">Prev</A>       <A HREF="vmspec-28.html">Next</A>       <A HREF="vmspec-12.html">Up</A>       <P>
</BODY>
</HTML> 