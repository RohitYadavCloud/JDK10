<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 --> <HTML> <HEAD>
<TITLE>vmspec: Managing Arrays</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING18></A>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-17.html">Prev</A>       <A HREF="vmspec-19.html">Next</A>       <A HREF="vmspec-12.html">Up</A>       <P>
<HR>
<A NAME=HEADING18-0></A>
<H2>3.6 Managing Arrays</H2>
<H3>newarray</H3>
Allocate new array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>newarray = 188<TR>
<TD>atype</TABLE>
<P>
<PRE>
Stack: ..., size =&gt; result<P>
</PRE>
size must be an integer. It represents the number of elements in the new array. <P>
atype is an internal code that indicates the type of array to allocate. Possible values for atype are as follows:
<TABLE BORDER="1"><TD>T_BOOLEAN<TD>4<TR>
<TD>T_CHAR<TD>5<TR>
<TD>T_FLOAT<TD>6<TR>
<TD>T_DOUBLE<TD>7<TR>
<TD>T_BYTE<TD>8<TR>
<TD>T_SHORT<TD>9<TR>
<TD>T_INT<TD>10<TR>
<TD>T_LONG<TD>11</TABLE>
<BR>A new array of <I>atype,</I> capable of holding <I>size </I>elements, is allocated, and result is a reference to this new object. Allocation of an array large enough to contain <I>size</I> items of <I>atype</I> is attempted. All elements of the array are initialized to zero.<P>
If size is less than zero, a <CODE>NegativeArraySizeException</CODE> is thrown. If there is not enough memory to allocate the array, an <CODE>OutOfMemoryError</CODE> is thrown.<P>
<H3>anewarray</H3>
Allocate new array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>anewarray = 189<TR>
<TD>indexbyte1<TR>
<TD>indexbyte2</TABLE>
 of references to objects<P>
<PRE>
Stack: ..., size=&gt; result<P>
</PRE>
size must be an integer. It represents the number of elements in the new array. <P>
<I>indexbyte1</I> and <I>indexbyte2 </I>are used to construct an index into the constant pool of the current class. The item at that index is resolved. The resulting entry must be a class.<P>
A new array of the indicated class type and capable of holding <I>size </I>elements is allocated, and result is a reference to this new object. Allocation of an array large enough to contain <I>size</I> items of the given class type is attempted. All elements of the array are initialized to <CODE>null</CODE>.<P>
If size is less than zero, a <CODE>NegativeArraySizeException</CODE> is thrown. If there is not enough memory to allocate the array, an <CODE>OutOfMemoryError</CODE> is thrown.<P>
<CODE>anewarray</CODE> is used to create a single dimension of an array of object references. For example, to create<P>
<PRE>
<CODE>new Thread[7]</CODE>
</PRE>
the following code is used:<P>
<PRE>
<CODE>bipush 7
anewarray &lt;Class &quot;java.lang.Thread&quot;&gt;</CODE>
</PRE>
<CODE>anewarray</CODE> can also be used to create the first dimension of a multi-dimensional array. For example, the following array declaration:<P>
<PRE>
<CODE>new int[6][]</CODE>
</PRE>
is created with the following code:<P>
<PRE>
<CODE>bipush 6
anewarray &lt;Class &quot;[I&quot;&gt;</CODE>
</PRE>
See <CODE>CONSTANT_Class</CODE> in the "Class File Format" chapter for information on array class names.<P>
<H3>multianewarray</H3>
Allocate new multi-dimensional array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>multianewarray = 197<TR>
<TD>indexbyte1<TR>
<TD>indexbyte2<TR>
<TD>dimensions</TABLE>
<P>
<PRE>
Stack: ..., size1 size2...sizen =&gt; result<P>
</PRE>
Each size must be an integer. Each represents the number of elements in a dimension of the array. <P>
<I>indexbyte1</I> and <I>indexbyte2 </I>are used to construct an index into the constant pool of the current class. The item at that index is resolved. The resulting entry must be an array class of one or more dimensions.<P>
<I>dimensions</I> has the following aspects:<P>
<UL>
<LI>It must be an integer &gt;=1. <P>
<LI>It represents the number of dimensions being created. It must be  the number of dimensions of the array class.<P>
<LI>It represents the number of elements that are popped off the stack. All must be integers greater than or equal to zero. These are used as the sizes of the dimension. For example, to create<P>
</UL>
<PRE>
<CODE> new int[6][3][]</CODE>
</PRE>
the following code is used:<P>
<PRE>
<CODE> bipush 6
 bipush 3
 multianewarray &lt;Class &quot;[[[I&quot;&gt; 2</CODE>
</PRE>
If any of the size arguments on the stack is less than zero, a <CODE>NegativeArraySizeException</CODE> is thrown. If there is not enough memory to allocate the array, an <CODE>OutOfMemoryError</CODE> is thrown.<P>
The result is a reference to the new array object.<P>
Note: More explanation needed about how this is an array of arrays.<P>
Note: It is more efficient to use <CODE>newarray</CODE> or <CODE>anewarray</CODE> when creating a single dimension.<P>
See <CODE>CONSTANT_Class</CODE> in the "Class File Format" chapter for information on array class names.<P>
<H3>arraylength</H3>

<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>arraylength = 190</TABLE>
Get length of array<P>
<PRE>
Stack: ..., objectref =&gt; ..., length<P>
</PRE>
objectref must be a reference to an array object. The length of the array is determined and replaces <I>objectref </I>on the top of the stack.<P>
If the <I>objectref </I>is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. <P>
<H3><A NAME=MARKER-9-81></A><A NAME=MARKER-8-82></A><A NAME=MARKER-8-83></A>iaload</H3>
Load integer from array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>iaload = 46</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index =&gt; ..., value<P>
</PRE>
arrayref must be a reference to an array of integers. index must be an integer. The integer <I>value</I> at position number index in the array is retrieved and pushed onto the top of the stack.<P>
If arrayref is <CODE>null</CODE> a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-9-84></A><A NAME=MARKER-8-85></A><A NAME=MARKER-8-86></A>laload</H3>
Load long integer from array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>laload = 47</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index =&gt; ..., value<CODE>-word1</CODE>, value<CODE>-word2</CODE><P>
</PRE>
arrayref must be a reference to an array of long integers. index must be an integer. The long integer <I>value</I> at position number index in the array is retrieved and pushed onto the top of the stack.<P>
If arrayref is <CODE>null</CODE> a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-9-87></A><A NAME=MARKER-8-88></A><A NAME=MARKER-8-89></A>faload</H3>
Load single float from array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>faload = 48</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index =&gt; ..., value<P>
</PRE>
arrayref must be a reference to an array of single-precision floating point numbers. index must be an integer. The single-precision floating point number <I>value</I> at position number index in the array is retrieved and pushed onto the top of the stack.<P>
If arrayref is <CODE>null</CODE> a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-9-90></A><A NAME=MARKER-8-91></A><A NAME=MARKER-8-92></A>daload</H3>
Load double float from array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>daload = 49</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index =&gt; ..., value<CODE>-word1</CODE>, value<CODE>-word2</CODE><P>
</PRE>
arrayref must be a reference to an array of double-precision floating point numbers. index must be an integer. The double-precision floating point number <I>value</I> at position number index in the array is retrieved and pushed onto the top of the stack.<P>
If arrayref is <CODE>null</CODE> a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-9-93></A><A NAME=MARKER-8-94></A><A NAME=MARKER-8-95></A>aaload</H3>
Load object reference from array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>aaload = 50</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index =&gt; ..., value<P>
</PRE>
arrayref must be a reference to an array of references to objects. index must be an integer. The object reference at position number index in the array is retrieved and pushed onto the top of the stack.<P>
If arrayref is <CODE>null</CODE> a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-9-96></A><A NAME=MARKER-8-99></A><A NAME=MARKER-8-100></A>baload</H3>
Load signed byte from array.
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>baload = 51</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index =&gt; ..., value<P>
</PRE>
arrayref must be a reference to an array of signed bytes. index must be an integer. The signed byte value at position number index in the array is retrieved, expanded to an integer, and pushed onto the top of the stack.<P>
If arrayref is <CODE>null</CODE> a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-8-99></A><A NAME=MARKER-8-100></A>caload</H3>
Load character from array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>caload = 52</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index =&gt; ..., value<P>
</PRE>
arrayref must be a reference to an array of characters. index must be an integer. The character value at position number index in the array is retrieved, zero-extended to an integer, and pushed onto the top of the stack.<P>
If arrayref is <CODE>null</CODE> a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-9-101></A><A NAME=MARKER-8-102></A><A NAME=MARKER-8-103></A>saload</H3>
Load short from array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>saload = 53</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index =&gt; ..., value<P>
</PRE>
arrayref must be a reference to an array of short integers. index must be an integer. The ;signed short integer value at position number index in the array is retrieved, expanded to an integer, and pushed onto the top of the stack.<P>
If arrayref is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-9-104></A><A NAME=MARKER-8-105></A><A NAME=MARKER-8-106></A>iastore</H3>
Store into integer array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>iastore = 79</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index, value =&gt; ...<P>
</PRE>
arrayref must be a reference to an array of integers, index must be an integer, and value an integer. The integer value is stored at position index in the array. <P>
If arrayref is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-9-107></A><A NAME=MARKER-8-108></A><A NAME=MARKER-8-109></A>lastore</H3>
Store into long integer array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>lastore = 80</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index, value<CODE>-word1</CODE>, value<CODE>-word2</CODE> =&gt; ...<P>
</PRE>
arrayref must be a reference to an array of long integers, index must be an integer, and value a long integer. The long integer value is stored at position index in the array. <P>
If arrayref is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array, an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-9-110></A><A NAME=MARKER-8-111></A><A NAME=MARKER-8-112></A>fastore</H3>
Store into single float array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>fastore = 81</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index, value =&gt; ...<P>
</PRE>
arrayref must be an array of single-precision floating point numbers, index must be an integer, and value a single-precision floating point number. The single float value is stored at position index in the array. <P>
If arrayref is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-9-113></A><A NAME=MARKER-8-114></A><A NAME=MARKER-8-115></A>dastore</H3>
Store into double float array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>dastore = 82</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index, value<CODE>-word1</CODE>, value<CODE>-word2</CODE> =&gt; ...<P>
</PRE>
arrayref must be a reference to an array of double-precision floating point numbers, index must be an integer, and value a double-precision floating point number. The double float value is stored at position index in the array. <P>
If arrayref is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-9-116></A><A NAME=MARKER-8-117></A><A NAME=MARKER-8-118></A>aastore</H3>
Store into object reference array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>aastore = 83</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index, value =&gt; ...<P>
</PRE>
arrayref must be a reference to an array of references to objects, index must be an integer, and value a reference to an object. The object reference value is stored at position index in the array. <P>
If arrayref is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array, an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
The actual type of value must be conformable with the actual type of the elements of the array. For example, it is legal to store an instance of class <CODE>Thread</CODE> in an array of class <CODE>Object</CODE>, but not vice versa. <I>(</I>See the <EM>Java Language Specification</EM> for information on how to determine whether a object reference is an instance of a class<I>.) </I>An <CODE>ArrayStoreException</CODE> is thrown if an attempt is made to store an incompatible object reference.<P>
Note: Mustn't refer to the Java Language Specification; give semantics here.<P>
<H3><A NAME=MARKER-9-119></A><A NAME=MARKER-8-122></A><A NAME=MARKER-8-123></A>bastore</H3>
Store into signed byte array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>bastore = 84</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index, value =&gt; ...<P>
</PRE>
arrayref must be a reference to an array of signed bytes, index must be an integer, and value an integer. The integer value is stored at position index in the array. If value is too large to be a signed byte, it is truncated.<P>
If arrayref is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-8-122></A><A NAME=MARKER-8-123></A>castore</H3>
Store into character array
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>castore = 85</TABLE>
<P>
<PRE>
Stack: ..., arrayref, index, value =&gt; ...<P>
</PRE>
arrayref must be an array of characters, index must be an integer, and value an integer. The integer value is stored at position index in the array. If value is too large to be a character, it is truncated.<P>
If arrayref is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of [the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<H3><A NAME=MARKER-9-124></A><A NAME=MARKER-8-125></A><A NAME=MARKER-8-126></A>sastore</H3>

<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>sastore = 86</TABLE>
Store into short array<P>
<PRE>
Stack: ..., array, index, value =&gt; ...<P>
</PRE>
arrayref must be an array of shorts, index must be an integer, and value an integer. The integer value is stored at position index in the array. If value is too large to be an short, it is truncated.<P>
If arrayref is <CODE>null</CODE>, a <CODE>NullPointerException</CODE> is thrown. If index is not within the bounds of the array an <CODE>ArrayIndexOutOfBoundsException</CODE> is thrown.<P>
<P>
<HR>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-17.html">Prev</A>       <A HREF="vmspec-19.html">Next</A>       <A HREF="vmspec-12.html">Up</A>       <P>
</BODY>
</HTML> 