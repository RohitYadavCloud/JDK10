<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 --> <HTML> <HEAD>
<TITLE>vmspec: Constant Pool</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING8></A>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-7.html">Prev</A>       <A HREF="vmspec-9.html">Next</A>       <A HREF="vmspec-5.html">Up</A>       <P>
<HR>
<A NAME=HEADING8-0></A>
<H2>2.3 <A NAME=MARKER-9-2></A>Constant Pool</H2>
Each item in the constant pool begins with a 1-byte tag:. The table below lists the valid tags and their values.
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TH>Constant Type<TH>Value<TR>
<TD><CODE>CONSTANT_Class</CODE><TD><CODE>7</CODE><TR>
<TD><CODE>CONSTANT_Fieldref</CODE><TD>9<TR>
<TD><CODE>CONSTANT_Methodref</CODE><TD>10<TR>
<TD><CODE>CONSTANT_InterfaceMethodref</CODE><TD>11<TR>
<TD><CODE>CONSTANT_String</CODE><TD>8<TR>
<TD><CODE>CONSTANT_Integer</CODE><TD>3<TR>
<TD><CODE>CONSTANT_Float</CODE><TD>4<TR>
<TD><CODE>CONSTANT_Long</CODE><TD>5<TR>
<TD><CODE>CONSTANT_Double</CODE><TD>6<TR>
<TD><CODE>CONSTANT_NameAndType</CODE><TD>12<TR>
<TD><CODE>CONSTANT_Utf8</CODE><TD>1<TR>
<TD><CODE>CONSTANT_Unicode</CODE><TD>2</TABLE>
<P>
Each tag byte is then followed by one or more bytes giving more information about the specific constant. <P>
<H3>CONSTANT_Class</H3>
<CODE>CONSTANT_Class</CODE> is used to represent a class or an interface.<P>
<PRE>
<CODE>CONSTANT_Class_info {</CODE>
<CODE> u1 tag;</CODE>
<CODE> u2 name_index;</CODE>
<CODE>}</CODE>
</PRE>
<H3>tag</H3>
The tag will have the value <CODE>CONSTANT_Class</CODE><P>
<H3>name_index</H3>
constant_pool[name_index] is a <CODE>CONSTANT_Utf8</CODE> giving the string name of the class.<P>
Because arrays are objects, the opcodes <CODE>anewarray</CODE> and <CODE>multianewarray</CODE> can reference array "classes" via <CODE>CONSTANT_Class</CODE> items in the constant pool. In this case, the name of the class is its signature. For example, the class name for <P>
<PRE>
<CODE>int[][] </CODE>
</PRE>
is <P>
<PRE>
<CODE>[[I</CODE>
<CODE></CODE>
</PRE>
The class name for <P>
<PRE>
<CODE>Thread[] </CODE>
</PRE>
is <P>
<PRE>
<CODE>&quot;[Ljava.lang.Thread;&quot;</CODE>
</PRE>
<H3>CONSTANT_{Fieldref,Methodref,InterfaceMethodref}</H3>
Fields, methods, and interface methods are represented by similar structures.<P>
<PRE>
<CODE>CONSTANT_Fieldref_info {</CODE>
<CODE> u1 tag;</CODE>
<CODE> u2 class_index;</CODE>
<CODE> u2 name_and_type_index;</CODE>
<CODE>}</CODE>
<CODE></CODE>
<CODE>CONSTANT_Methodref_info {</CODE>
<CODE> u1 tag;</CODE>
<CODE> u2 class_index;</CODE>
<CODE> u2 name_and_type_index;</CODE>
<CODE>}</CODE>
<CODE></CODE>
<CODE>CONSTANT_InterfaceMethodref_info {</CODE>
<CODE> u1 tag;</CODE>
<CODE> u2 class_index;</CODE>
<CODE> u2 name_and_type_index;</CODE>
<CODE>}</CODE>
</PRE>
<H3>tag</H3>
The tag will have the value <CODE>CONSTANT_Fieldref</CODE>, <CODE>CONSTANT_Methodref</CODE>, or <CODE>CONSTANT_InterfaceMethodref.</CODE><P>
<H3>class_index</H3>
<CODE>constant_pool[class_index] </CODE>will be an entry of type <CODE>CONSTANT_Class</CODE> giving the name of the class or interface containing the field or method.<P>
For <CODE>CONSTANT_Fieldref</CODE> and <CODE>CONSTANT_Methodref</CODE>, the <CODE>CONSTANT_Class</CODE> item must be an actual class. For <CODE>CONSTANT_InterfaceMethodref</CODE>, the item must be an interface which purports to implement the given method.<P>
<H3>name_and_type_index</H3>
<CODE>constant_pool[name_and_type_index]</CODE> will be an entry of type <CODE>CONSTANT_NameAndType. </CODE>This constant pool entry indicates the name and signature of the field or method.<P>
<H3>CONSTANT_String</H3>
CONSTANT_String is used to represent constant objects of the built-in type String.<P>
<PRE>
<CODE>CONSTANT_String_info {</CODE>
<CODE> u1 tag;</CODE>
<CODE> u2 string_index;</CODE>
<CODE>}</CODE>
</PRE>
<H3>tag</H3>
The tag will have the value <CODE>CONSTANT_String</CODE><P>
<H3>string_index</H3>
<CODE>constant_pool[string_index]</CODE> is a <CODE>CONSTANT_Utf8</CODE> string giving the value to which the String object is initialized.<P>
<H3>CONSTANT_Integer and CONSTANT_Float</H3>
<CODE>CONSTANT_Integer </CODE>and <CODE>CONSTANT_Float</CODE> represent four-byte constants.<P>
<PRE>
<CODE></CODE>
<CODE>CONSTANT_Integer_info {</CODE>
<CODE> u1 tag;</CODE>
<CODE> u4 bytes;</CODE>
<CODE>}</CODE>
<CODE></CODE>
<CODE>CONSTANT_Float_info {</CODE>
<CODE> u1 tag;</CODE>
<CODE> u4 bytes;</CODE>
<CODE>}</CODE>
</PRE>
<H3>tag</H3>
The tag will have the value <CODE>CONSTANT_Integer </CODE>or <CODE>CONSTANT_Float</CODE><P>
<H3>bytes</H3>
For integers, the four bytes are the integer value. For floats, they are the IEEE 754 standard representation of the floating point value. These bytes are in network (high byte first) order.<P>
<H3>CONSTANT_Long and CONSTANT_Double</H3>
<CODE>CONSTANT_Long </CODE>and <CODE>CONSTANT_Double</CODE> represent eight-byte constants.<P>
<PRE>
<CODE>CONSTANT_Long_info {</CODE>
<CODE> u1 tag;</CODE>
<CODE> u4 high_bytes;</CODE>
<CODE> u4 low_bytes;</CODE>
<CODE>}</CODE>
<CODE></CODE>
<CODE>CONSTANT_Double_info {</CODE>
<CODE> u1 tag;</CODE>
<CODE> u4 high_bytes;</CODE>
<CODE> u4 low_bytes;</CODE>
<CODE>}</CODE>
<CODE></CODE>
</PRE>
All eight-byte constants take up two spots in the constant pool. If this is the nth item in the constant pool, then the next item will be numbered n+2.<P>
<H3>tag</H3>
The tag will have the value <CODE>CONSTANT_Long </CODE>or<CODE> CONSTANT_Double</CODE>.<P>
<H3>high_bytes, low_bytes</H3>
For <CODE>CONSTANT_Long</CODE>, the 64-bit value is (<CODE>high_bytes</CODE> &lt;&lt; 32) + <CODE>low_bytes</CODE>.<P>
For <CODE>CONSTANT_Double</CODE>, the 64-bit value, <CODE>high_bytes</CODE> and <CODE>low_bytes</CODE> together represent the standard IEEE 754 representation of the double-precision floating point number.<P>
<H3>CONSTANT_NameAndType</H3>
<CODE>CONSTANT_NameAndType</CODE> is used to represent a field or method, without indicating which class it belongs to.<P>
<PRE>
<CODE>CONSTANT_NameAndType_info {</CODE>
<CODE> u1 tag;</CODE>
<CODE> u2 name_index;</CODE>
<CODE> u2 signature_index;</CODE>
<CODE>}</CODE>
</PRE>
<H3>tag</H3>
The tag will have the value <CODE>CONSTANT_NameAndType.</CODE><P>
<H3>name_index</H3>
<CODE>constant_pool[name_index]</CODE> is a <CODE>CONSTANT_Utf8</CODE> string giving the name of the field or method.<P>
<H3>signature_index</H3>
<CODE>constant_pool[signature_index]</CODE> is a <CODE>CONSTANT_Utf8</CODE> string giving the signature of the field or method.<P>
<H3>CONSTANT_Utf8 and CONSTANT_Unicode</H3>
<CODE>CONSTANT_Utf8</CODE> and <CODE>CONSTANT_Unicode</CODE> are used to represent constant string values.<P>
<CODE>CONSTANT_Utf8</CODE> strings are "encoded" so that strings containing only non-null ASCII characters, can be represented using only one byte per character, but characters of up to 16 bits can be represented:<P>
All characters in the range 0x0001 to 0x007F are represented by a single byte:<P>
<PRE>
<CODE>     +-+-+-+-+-+-+-+-+</CODE>
<CODE>     |0|7bits of data|</CODE>
<CODE>     +-+-+-+-+-+-+-+-+</CODE>
</PRE>
<BR>The null character (0x0000) and characters in the range 0x0080 to 0x07FF are represented by a pair of two bytes:<P>
<PRE>
<CODE>     +-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+-+</CODE>
<CODE>     |1|1|0| 5 bits |   |1|0|  6 bits   |</CODE>
<CODE>     +-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+-+</CODE>
</PRE>
<BR>Characters in the range 0x0800 to 0xFFFF are represented by three bytes:<P>
<PRE>
<CODE>     +-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+-+</CODE>
<CODE>     |1|1|1|0|4 bits |   |1|0|  6 bits   |   |1|0|  6 bits   |</CODE>
<CODE>     +-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+-+</CODE>
</PRE>
<P>
There are two differences between this format and the "standard" UTF-8 format. First, the null byte (0x00) is encoded in two-byte format rather than one-byte, so that our strings never have embedded nulls. Second, only the one-byte, two-byte, and three-byte formats are used. We do not recognize the longer formats.<P>
<PRE>
<CODE>CONSTANT_Utf8_info {</CODE>
<CODE> u1 tag;</CODE>
<CODE> u2 length;</CODE>
<CODE> u1 bytes[length];</CODE>
<CODE>}</CODE>
<CODE></CODE>
<CODE>CONSTANT_Unicode_info {</CODE>
<CODE> u1 tag;</CODE>
<CODE> u2 length;</CODE>
<CODE> u2 bytes[length];</CODE>
<CODE>}</CODE>
</PRE>
<H3>tag</H3>
The tag will have the value <CODE>CONSTANT_Utf8 </CODE>or<CODE> CONSTANT_Unicode</CODE>.<P>
<H3>length</H3>
The number of bytes in the string. These strings are not null terminated.<P>
<H3>bytes</H3>
The actual bytes of the string. <P>
<HR>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-7.html">Prev</A>       <A HREF="vmspec-9.html">Next</A>       <A HREF="vmspec-5.html">Up</A>       <P>
</BODY>
</HTML> 