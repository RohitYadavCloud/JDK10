%!
%%Title: synchronization.html
%%DocumentFonts: NewCenturySchlbk-Roman NewCenturySchlbk-Bold NewCenturySchlbk-Italic NewCenturySchlbk-BoldItalic Courier Courier-Bold Courier-Oblique Courier-BoldOblique
%%Creator: html2ps 0.1 beta, written by Jan Karrman, jan@tdb.uu.se
%%EndComments
save
/D {def} def /E {exch} D
/M {moveto} D
/S {show} D
/R {rmoveto} D
/L {lineto} D
/RL {rlineto} D
/SW {stringwidth} D
/GI {getinterval} D
/PI {putinterval} D
/U {gsave CP currentfont /FontInfo get /UnderlinePosition get
 0 E currentfont /FontMatrix get dtransform E pop add newpath M
 dup SW RL stroke grestore S } D
/B {/r E D gsave -10 0 R CP 
  newpath r 0 360 arc closepath fill grestore } D
/OB {/r E D gsave -10 0 R CP 
  newpath r 0 360 arc closepath stroke grestore } D
/NP {PN 0 ne {showpage} if 0.6 setlinewidth 70 756 translate
 F dup scale /BP true D /PN PN 1 add D NO {/OF currentfont D RF findfont
 10 scalefont setfont W 2 div LE neg 40 sub M PN ST cvs S OF setfont} if
 XO SZ SL get neg M} D
/SF {dup SZ SL 3 2 roll put dup -1.2 mul /YI E D E findfont E scalefont
 setfont} D
/FS {CF MK PF {1 or} if and or /CF E D FR SL CF put FL CF get E SF} D
/RF {/NewCenturySchlbk-Roman} D
/BF {/NewCenturySchlbk-Bold} D
/IF {/NewCenturySchlbk-Italic} D
/IB {/NewCenturySchlbk-BoldItalic} D
/FF {/Courier} D
/FB {/Courier-Bold} D
/FI {/Courier-Oblique} D
/FT {/Courier-BoldOblique} D
/FL [RF FF BF FB IF FI IB FT] D
/reencodeISO {
dup dup findfont dup length dict begin
{ 1 index /FID ne { def }{ pop pop } ifelse } forall
/Encoding ISOLatin1Encoding D
currentdict end definefont
} D
/ISOLatin1Encoding [
/space/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
/parenleft/parenright/asterisk/plus/comma/minus/period/slash
/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve
/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut
/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar
/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
/yacute/thorn/ydieresis
] D
[RF BF IF IB FF FB FI FT] {reencodeISO D} forall

/WK ( ) D
/BS {/PC E D /TX E D /fin false D /BW WK SW pop D /CW 0 D /LK 0 D /SC 0 D
 /RT TX D {RT WK search {/NW E D pop /RT E D /WH NW SW pop D CW WH add LL gt
 {TX SC LK SC sub GI PC /SC LK D /CW WH BW add D}
 {/CW CW WH add BW add D} ifelse
 /LK LK NW length add 1 add D} {pop exit} ifelse} loop
 /fin true D /LC TX length D /WH RT SW pop D CW WH add LL gt
 {TX SC LK SC sub GI PC NL RT dup () ne {PC} {pop} ifelse}
 {TX SC LC SC sub GI PC} ifelse} D

/W {453 F div} D
/LE {651 F div} D
/BL {HM not {CP E pop XO E M} if} D
/NL {CP /YC E D pop XO YC M YC LE neg gt
 {YI CI sub dup 0 lt BP not and {dup 0 E R CI add /CI E D} {pop} ifelse}
 {NP} ifelse} D
/RS {/TM E D /CN 0 D TM
 {dup 9 eq E 10 eq or {TM CN ( ) PI} if
  /CN CN 1 add D} forall /CN 0 D /BK HM EN and {0} {1} ifelse D TM
 {dup 32 ne {TM CN 3 2 roll put /CN CN 1 add D /BK 0 D}
 {pop BK 0 eq {TM CN 32 put /CN CN 1 add D} if /BK 1 D} ifelse}
  forall TM 0 CN GI dup () ne 
  {dup CN 1 sub get 32 eq {/EN false D} {/EN true D} ifelse} if} D
/join {2 copy length E length add string dup 4 2 roll 2 index 0 3 index
 PI E length E PI} bind D

/CP {currentpoint} D
/WR {dup () eq {pop} {IG {DE search {pop pop} if /IG false D} if
 PB {dup 0 get 10 ne {(\n) E join} if /PB false D} if
 PP {dup 0 get 10 ne {(\n) E join} if /PP false D} if
 (\n) search {TR /CI 0 D /NC 0 D NL pop WR} {TR} ifelse} ifelse} D
/TR {(\t) search {dup length /NC E NC add D SH MS 0 8 NC 8 mod sub dup
 /NC E NC add D GI SH pop TR} {dup length /NC E NC add D SH} ifelse
 /BP false D} D
/SH {CP E pop LE neg lt {NP} if AU AF and UF or {U} {S} ifelse} D
/ON {AR AI NN get 1 add dup AR AI 3 -1 roll put ST cvs length dup ST E (. ) PI
 ST 0 3 -1 roll 2 add GI dup SW pop neg 0 R SH} D
/SP {YI E /YI E D NL /YI E D} D
/BR {BN} D
/BN {PF {WR} {BT NL} ifelse /HM false D} D
/AB {CH E 0 E put CH join WB} D
/NN {dup 0 lt {pop 0} if} D
/HD {IG {DE search {pop pop} if /IG false D} if} D
/DH {pop BT} D
/TL {} D
/LT {pop BT} D
/H  {1 sub /HL E D BN CP E pop LE neg WW add lt {NP} if
 BH SP /SL SL 1 add D HS HL get HT HL get FS} D
/EH {BN AH SP /SL SL 1 sub NN D /CF 0 D SZ SL get FR SL get FS} D
/BT {IG {DE search {pop pop} if /IG false D} if RS dup dup () ne E ( ) ne and
 {/LS LL D /LL W CP pop sub D {/CI 0 D SH /BP false D fin not {NL} if
  /HM true D /LL LS D} BS} {S} ifelse} D
/P  {PF {WR /PP true D} {BN AE not {AH SP} if} ifelse} D
/HR {BN 0 CP E pop M gsave W 0 RL stroke grestore
 /CI 0 D BP {/BP false D} if NL} D
/AD {BN /AE true D AH SP IF 11 SF} D
/DA {BN /AE false D AH SP RF 11 SF} D
/PR {BN /CF 0 D 9 PS mul 1 FS /PF true D /PB true D /NC 0 D} D
/PW {pop PR} D
/RP {dup () ne {dup dup length 1 sub get 10 ne {(\n) join} if} if
 WR AH SP /CF 0 D 11 0 FS /PF false D} D
/SI {/XO AI LG add NN IN mul BC NN BI mul add D /LL W XO sub D} D
/DT {BN /LG LG 1 sub D SI /LG LG 1 add D BL} D
/DD {BN SI BL} D
/DL {BN XO 0 eq {AH SP} if /LG LG 1 add D BL} D
/LD {BN LG 0 gt {/LG LG 1 sub D} if SI XO 0 eq {AH SP} if BL} D
/UL {BT XO 0 eq {AH SP} {NL} ifelse NR AI NN 0 put /UI UI 1 add D
 /AI AI 1 add D SI BL} D
/LU {BT /UI UI 1 sub D /AI AI 1 sub D SI XO 0 eq {AH SP} {NL} ifelse BL} D
/OL {BT XO 0 eq {AH SP} {NL} ifelse NR AI NN 1 put /AI AI 1 add D SI BL} D
/LO {BT AR AI NN 0 put /AI AI 1 sub D SI XO 0 eq {AH SP} {NL} ifelse BL} D
/LI {BN /BP false D /CI 0 D CP E pop LE neg lt {NP} if NR AI 1 sub NN get 1 eq
 {ON} {0 3 R 2.5 UI 2 mod 0 eq {OB} {B} ifelse 0 -3 R} ifelse BL} D
/BQ {BN AH SP /BC BC 1 add D SI BL} D
/QB {BN AH SP /BC BC 1 sub D SI BL} D
/WB {PF {WR} {BT} ifelse} D
/A  {WB /AF true D} D
/EA {WB /AF false D} D
/CM {WB /IG true D /DE (-->) D} D
/SK {PF {(<) join WR} {BT /IG true D /DE (>) D} ifelse} D
/SS {SZ SL get /SL SL 1 add D} D
/I  {WB SS 4 FS} D
/BD {WB SS 2 FS} D
/TT {WB SS 1 FS} D
/KB {WB SS /CF 0 D 3 FS} D
/CT {WB SS /CF 0 D 4 FS} D
/SM {WB SS /CF 0 D 1 FS} D
/ES {WB /SL SL 1 sub NN D /CF 0 D SZ SL get FR SL get FS} D
/UN {WB /UF true D} D
/NU {WB /UF false D} D

/F 1 D
/BH -35 D
/AH -28 D
/LL W D
/XO 0 D
/YI 0 D
/CI 0 D
/LG 0 D
/AI 0 D
/UI 0 D
/IN 30 D
/BI 12 D
/WW 50 D
/PS 1 D
/AR [0 0 0 0 0 0 0 0 0 0] D
/NR [0 0 0 0 0 0 0 0 0 0] D
/FR [0 0 0 0 0 0 0 0 0 0] D
/SZ [0 0 0 0 0 0 0 0 0 0] D
/HS [19 17 15 13 12 11] D
/HT [2 2 2 2 2 2] D
/SL 0 D
/CF 0 D
/BC 0 D
/MK 7 D
/PN 0 D
/MS (        ) D
/CH 1 string D
/ST 6 string D
/IG false D
/HM false D
/PF false D
/EN false D
/UF false D
/PP false D
/AE false D
/AF false D
/NO false D
/AU true D
/BP true D
%%EndProlog
save
RF 11 SF
0 LE neg 20 sub M
(

)HD(
)TL(Synchronization)LT(
)DH(

)SK(table width=100%>
)SK(tr>
)SK(td align=left>
)A( Previous |  )WB()EA()A( Next |  )WB()EA()A( Trail Map |  )WB()EA()A( Writing Java Programs |  )WB()EA(
)SK(td>
)SK(td align=right>
)A()BD()I(Threads of Control)ES()ES()EA(
)SK(/td>
)SK(/tr>
)SK(/table>
)P(
)SK(hr size=4>

)2 H(
    Synchronization
)EH(
)P(
)BQ(

So far, this lesson has contained examples with independent,
asynchronous threads. That is, each thread contained all of the
data and methods required for its execution and didn't require
any outside resources or methods. In addition, the threads in
those examples ran at their own pace without concern over the
state or activities of any other concurrently running threads.

)P(
However, there are many interesting situations where separate
concurrently running threads do share data and must consider
the state and activities of those other threads. One such set of
programming situations are known as Producer/Consumer scenarios
where the Producer generates a stream of data which then is consumed 
by a Consumer.

)P(
For example, you can imagine a Java application where one thread
\(the producer\) writes data to a file while a second thread \(the consumer\)
reads data from the same file. Or, as you type characters on the keyboard,
the producer thread places key events in an event queue and the consumer
thread reads the events from the same queue. Both of these examples use
concurrent threads that share a common resource: a file, an event queue.
And because the threads share a common resource, they must be synchronized in
some way.

)P(
This lesson teaches you about Java thread synchronization through
a simple Producer/Consumer example.

)4 H(Producer/Consumer Example)EH(
)BQ(
The )A(Producer)EA( generates integers
ranging from 0 to 9, stores it in a "CubbyHole" object, prints the
generated number, and \(just to make the synchronization problem more
interesting\) the Producer sleeps for a random amount of time between 0 and
100 milliseconds.
)BQ(
)PR(
class Producer extends Thread {
    private CubbyHole cubbyhole;
    private int number;

    public Producer\(CubbyHole c, int number\) {
	cubbyhole = c;
	this.number = number;
    }

    public void run\(\) {
	for \(int i = 0; i < 10; i++\) {
	    cubbyhole.put\(i\);
	    System.out.println\("Producer #" + this.number + " put: " + i\);
	    try {
	        sleep\(\(int\)\(Math.random\(\) * 100\)\);
	    } catch \(InterruptedException e\) {
	    }
	}
    }
}
)RP(
)QB(
The )A(Consumer)EA(, being ravenous,
consumes all integers from the CubbyHole \(the exact same object into
which the Producer put the integers in the first place\) as quickly
as they become available.
)BQ(
)PR(
class Consumer extends Thread {
    private CubbyHole cubbyhole;
    private int number;

    public Consumer\(CubbyHole c, int number\) {
	cubbyhole = c;
	this.number = number;
    }

    public void run\(\) {
	int value = 0;
	for \(int i = 0; i < 10; i++\) {
	    value = cubbyhole.get\(\);
	    System.out.println\("Consumer #" + this.number + " got: " + value\);
	}
    }
}

)RP(
)QB(

The Producer and Consumer in this example share data through
a common )SM(CubbyHole)ES( object. And you will note
that neither the Producer nor the Consumer make any effort whatsoever
to ensure that the Consumer is getting each value produced once
and only once. The synchronization between these two threads actually
occurs at a lower level, within the )SM(get\(\))ES( and )SM(put\(\))ES(
methods of the CubbyHole object. However, let's assume for a moment that
no synchronization between these two threads and talk about the potential
problems that might arise in that situation.

)P(
One problem that might arise if the Producer and Consumer threads
make no arrangements to run synchronously occurs when the Producer
is quicker than the Consumer and generates two numbers before
the Consumer has a chance to consume the first one. Thus the Consumer
would skip a number. Part of the output might look like this:
)BQ(
)PR(
    . . .

Consumer #1 got: 3
Producer #1 put: 4
Producer #1 put: 5
Consumer #1 got: 5

    . . .
)RP(
)QB(
Another problem that might arise is when the Consumer is quicker than
the Producer and consumes the same value twice. In this situation, the Consumer
would print the same value twice and might produce output that looked like this:
)BQ(
)PR(
    . . .

Producer #1 put: 4
Consumer #1 got: 4
Consumer #1 got: 4
Producer #1 put: 5

    . . .
)RP(
)QB(
Either way, the result is wrong. You want the Consumer to get each
integer produced by the Producer exactly once.
Problems, such as those just described, that arise from multiple,
asynchronously executing threads trying to a single object at the same time
and getting the wrong result, are called )I(race conditions)ES(.

)P(
To prevent race conditions in our Producer/Consumer example,
the storage of a new integer into the CubbyHole by the Producer
must be synchronized with the retrieval of an integer from the
CubbyHole by the Consumer. The Consumer must consume each integer
exactly once. Objects such as the CubbyHole, which are shared
between two threads and whose accesses must be synchronized,
are called )I(condition variables)ES(. The Java language
allows you to synchronize threads around a condition variable
through the use of )I(monitors)ES(.
)QB(

)4 H(Monitors)EH(
)BQ(
The Java language and runtime system support thread synchronization 
through the use of )I(monitors)ES( which were first outlined
in C. A. R. Hoare's article )I(Communicating Sequential Processes)ES(
\()I(Communications of the ACM)ES(, Vol. 21, No. 8, August 1978, pp. 666-677\).
In general, a monitor is associated with a specific data item \(the condition variable\)
and functions as a lock on that data. When a thread holds the monitor
for some data item, other threads are locked out and cannot inspect or
modify the data.
)P(
The code segments within a program that make it possible for separate,
concurrent threads to access the same data items are known as
)I(critical sections)ES(. In the Java language, you identify critical sections
in your program with the )SM(synchronized)ES( keyword.
)BR()BD(Note:)ES( Generally, critical sections in Java programs
are methods. You can mark smaller code segments as synchronized.
However, this violates object-oriented paradigms and leads to confusing
code that is difficult to debug and maintain. For the majority of
your Java programming purposes, it's best to use )SM(synchronized)ES(
only at the method level.
)P(
In the Java language, a unique monitor is associated with every object that has a
synchronized method. The )A(CubbyHole)EA(
class for the Producer/Consumer example introduced above has two
synchronized methods: the )SM(put\(\))ES( method used to change the
value in the CubbyHole and the )SM(get\(\))ES( method used to retrieve
the current value.
)EA(
)BQ(
)PR(
class CubbyHole {
    private int seq;
    )BD(private boolean available = false;)ES(

    public )BD(synchronized)ES( int get\(\) {
        )BD(while \(available == false\) {
	    try {
		wait\(\);
	    } catch \(InterruptedException e\) {
	    }
	}
        available = false;)ES(
	return seq;
    }

    public )BD(synchronized)ES( void put\(int value\) {
	seq = value;
        )BD(available = true;
        notify\(\);)ES(
    }
}
)RP(
)QB(
In addition, the )SM(CubbyHole)ES( has two private variables: )SM(seq)ES(
which is the current contents of the CubbyHole, and the boolean variable
)SM(available)ES( which indicates whether the CubbyHole contents
can be retrieved. When )SM(available)ES( is true the Producer has
just put a new value in the CubbyHole and the Consumer has not yet
consumed it. The Consumer can only consume the value in the CubbyHole
when )SM(available)ES( is true.
)P(
Because CubbyHole has synchronized methods, the Java language provides
a unique monitor for each instance of CubbyHole, including
the one shared by the Producer and the Consumer. Whenever the Producer
calls the CubbyHole's )SM(put\(\))ES( method, the Producer acquires
the monitor for the CubbyHole thereby preventing the Consumer
from calling the CubbyHole's)SM(get\(\))ES( method.
)BQ(
)PR(
public synchronized void put\(int value\) {
	// monitor has been acquired by the Producer
    seq = value;
    available = true;
    notify\(\);
	// monitor is released by the Producer
}
)RP(
)QB(
When the )SM(put\(\))ES( method returns, the Producer releases the
monitor thereby unlocking the CubbyHole.
)P(
Conversely, whenever the Consumer calls the CubbyHole's )SM(get\(\))ES(
method, the Consumer acquires the monitor for the CubbyHole thereby
preventing the Producer from calling the )SM(put\(\))ES( method.
)BQ(
)PR(
public )BD(synchronized)ES( int get\(\) {
	// monitor has been acquired by the Consumer
    while \(available == false\) {
	try {
	    wait\(\);
	} catch \(InterruptedException e\) {
	}
    }
    available = false;
    return seq;
	// monitor is released by the Consumer
}
)RP(
)QB(
The acquisition and release of a monitor is done atomically by the
Java runtime system. This ensures that race conditions cannot occur
in the underlying implementation of the threads and ensures data
integrity.
)P(
You might have noticed a potential problem in CubbyHole's )SM(put\(\))ES(
and )SM(get\(\))ES( methods. At the beginning
of the )SM(get\(\))ES( method, if the value in the CubbyHole
is not available \(that is, the Producer has not generated a new
number since the last time the Consumer consumed it\) then the
Consumer waits for the Producer to put a new value into the CubbyHole.
So, the question arises--how can the Producer put a new value into
the CubbyHole, if the Consumer holds the monitor \(the Consumer holds
the CubbyHole's monitor because it's within the synchronized
method )SM(get\(\))ES(\)?
)P(
Well, the designers of the Java language thought of this too.
When the thread enters the )SM(wait\(\))ES( method, the monitor is
released atomically, and when the thread exits the )SM(wait\(\))ES( method,
the monitor is acquired again. This gives the Producer the opportunity
to acquire the monitor and put a new value into the CubbyHole.
)QB(

)4 H(The Main Program)EH(
)BQ(
Here's a small stand-alone )A(Java application)EA(
that creates a CubbyHole object, one Producer, one Consumer, and then starts both the Producer
and the Consumer.
)BQ(
)PR(
class ProducerConsumerTest {
    public static void main\(String args[]\) {
	CubbyHole c = new CubbyHole\(\);
	Producer p1 = new Producer\(c, 1\);
	Consumer c1 = new Consumer\(c, 1\);

        p1.start\(\);
        c1.start\(\);
    }
}
)RP(
)QB(
)QB(

)4 H(The Output)EH(
)BQ(
Here's the output of ProducerConsumerTest.
)BQ(
)PR(
Producer #1 put: 0
Consumer #1 got: 0
Producer #1 put: 1
Consumer #1 got: 1
Producer #1 put: 2
Consumer #1 got: 2
Producer #1 put: 3
Consumer #1 got: 3
Producer #1 put: 4
Consumer #1 got: 4
Producer #1 put: 5
Consumer #1 got: 5
Producer #1 put: 6
Consumer #1 got: 6
Producer #1 put: 7
Consumer #1 got: 7
Producer #1 put: 8
Consumer #1 got: 8
Producer #1 put: 9
Consumer #1 got: 9
)RP(
)QB(

)P(
)BD(Try this:)ES( Remove the lines that are shown in bold in
the listing of the CubbyHole class )A(shown above)EA(.
Recompile the program and run it again. What happened? Because no explicit effort
has been made to synchronize the Producer and Consumer threads, the
Consumer consumes with reckless abandon and gets a whole bunch of
zeros instead of getting each integer between 0 and 9 exactly once.
)QB(

)QB(
)P(
)SK(hr size=4>
)P(
)SK(table width=100%>
)SK(tr>
)SK(td align=left>
)A( Previous |  )WB()EA()A( Next |  )WB()EA()A( Trail Map |  )WB()EA()A( Writing Java Programs |  )WB()EA(
)SK(td>
)SK(td align=right>
)A()BD()I(Threads of Control)ES()ES()EA(
)SK(/td>
)SK(/tr>
)SK(/table>


)WB showpage restore
