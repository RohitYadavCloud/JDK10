%!
%%Title: moreaccessors.html
%%DocumentFonts: NewCenturySchlbk-Roman NewCenturySchlbk-Bold NewCenturySchlbk-Italic NewCenturySchlbk-BoldItalic Courier Courier-Bold Courier-Oblique Courier-BoldOblique
%%Creator: html2ps 0.1 beta, written by Jan Karrman, jan@tdb.uu.se
%%EndComments
save
/D {def} def /E {exch} D
/M {moveto} D
/S {show} D
/R {rmoveto} D
/L {lineto} D
/RL {rlineto} D
/SW {stringwidth} D
/GI {getinterval} D
/PI {putinterval} D
/U {gsave CP currentfont /FontInfo get /UnderlinePosition get
 0 E currentfont /FontMatrix get dtransform E pop add newpath M
 dup SW RL stroke grestore S } D
/B {/r E D gsave -10 0 R CP 
  newpath r 0 360 arc closepath fill grestore } D
/OB {/r E D gsave -10 0 R CP 
  newpath r 0 360 arc closepath stroke grestore } D
/NP {PN 0 ne {showpage} if 0.6 setlinewidth 70 756 translate
 F dup scale /BP true D /PN PN 1 add D NO {/OF currentfont D RF findfont
 10 scalefont setfont W 2 div LE neg 40 sub M PN ST cvs S OF setfont} if
 XO SZ SL get neg M} D
/SF {dup SZ SL 3 2 roll put dup -1.2 mul /YI E D E findfont E scalefont
 setfont} D
/FS {CF MK PF {1 or} if and or /CF E D FR SL CF put FL CF get E SF} D
/RF {/NewCenturySchlbk-Roman} D
/BF {/NewCenturySchlbk-Bold} D
/IF {/NewCenturySchlbk-Italic} D
/IB {/NewCenturySchlbk-BoldItalic} D
/FF {/Courier} D
/FB {/Courier-Bold} D
/FI {/Courier-Oblique} D
/FT {/Courier-BoldOblique} D
/FL [RF FF BF FB IF FI IB FT] D
/reencodeISO {
dup dup findfont dup length dict begin
{ 1 index /FID ne { def }{ pop pop } ifelse } forall
/Encoding ISOLatin1Encoding D
currentdict end definefont
} D
/ISOLatin1Encoding [
/space/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
/parenleft/parenright/asterisk/plus/comma/minus/period/slash
/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve
/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut
/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar
/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
/yacute/thorn/ydieresis
] D
[RF BF IF IB FF FB FI FT] {reencodeISO D} forall

/WK ( ) D
/BS {/PC E D /TX E D /fin false D /BW WK SW pop D /CW 0 D /LK 0 D /SC 0 D
 /RT TX D {RT WK search {/NW E D pop /RT E D /WH NW SW pop D CW WH add LL gt
 {TX SC LK SC sub GI PC /SC LK D /CW WH BW add D}
 {/CW CW WH add BW add D} ifelse
 /LK LK NW length add 1 add D} {pop exit} ifelse} loop
 /fin true D /LC TX length D /WH RT SW pop D CW WH add LL gt
 {TX SC LK SC sub GI PC NL RT dup () ne {PC} {pop} ifelse}
 {TX SC LC SC sub GI PC} ifelse} D

/W {453 F div} D
/LE {651 F div} D
/BL {HM not {CP E pop XO E M} if} D
/NL {CP /YC E D pop XO YC M YC LE neg gt
 {YI CI sub dup 0 lt BP not and {dup 0 E R CI add /CI E D} {pop} ifelse}
 {NP} ifelse} D
/RS {/TM E D /CN 0 D TM
 {dup 9 eq E 10 eq or {TM CN ( ) PI} if
  /CN CN 1 add D} forall /CN 0 D /BK HM EN and {0} {1} ifelse D TM
 {dup 32 ne {TM CN 3 2 roll put /CN CN 1 add D /BK 0 D}
 {pop BK 0 eq {TM CN 32 put /CN CN 1 add D} if /BK 1 D} ifelse}
  forall TM 0 CN GI dup () ne 
  {dup CN 1 sub get 32 eq {/EN false D} {/EN true D} ifelse} if} D
/join {2 copy length E length add string dup 4 2 roll 2 index 0 3 index
 PI E length E PI} bind D

/CP {currentpoint} D
/WR {dup () eq {pop} {IG {DE search {pop pop} if /IG false D} if
 PB {dup 0 get 10 ne {(\n) E join} if /PB false D} if
 PP {dup 0 get 10 ne {(\n) E join} if /PP false D} if
 (\n) search {TR /CI 0 D /NC 0 D NL pop WR} {TR} ifelse} ifelse} D
/TR {(\t) search {dup length /NC E NC add D SH MS 0 8 NC 8 mod sub dup
 /NC E NC add D GI SH pop TR} {dup length /NC E NC add D SH} ifelse
 /BP false D} D
/SH {CP E pop LE neg lt {NP} if AU AF and UF or {U} {S} ifelse} D
/ON {AR AI NN get 1 add dup AR AI 3 -1 roll put ST cvs length dup ST E (. ) PI
 ST 0 3 -1 roll 2 add GI dup SW pop neg 0 R SH} D
/SP {YI E /YI E D NL /YI E D} D
/BR {BN} D
/BN {PF {WR} {BT NL} ifelse /HM false D} D
/AB {CH E 0 E put CH join WB} D
/NN {dup 0 lt {pop 0} if} D
/HD {IG {DE search {pop pop} if /IG false D} if} D
/DH {pop BT} D
/TL {} D
/LT {pop BT} D
/H  {1 sub /HL E D BN CP E pop LE neg WW add lt {NP} if
 BH SP /SL SL 1 add D HS HL get HT HL get FS} D
/EH {BN AH SP /SL SL 1 sub NN D /CF 0 D SZ SL get FR SL get FS} D
/BT {IG {DE search {pop pop} if /IG false D} if RS dup dup () ne E ( ) ne and
 {/LS LL D /LL W CP pop sub D {/CI 0 D SH /BP false D fin not {NL} if
  /HM true D /LL LS D} BS} {S} ifelse} D
/P  {PF {WR /PP true D} {BN AE not {AH SP} if} ifelse} D
/HR {BN 0 CP E pop M gsave W 0 RL stroke grestore
 /CI 0 D BP {/BP false D} if NL} D
/AD {BN /AE true D AH SP IF 11 SF} D
/DA {BN /AE false D AH SP RF 11 SF} D
/PR {BN /CF 0 D 9 PS mul 1 FS /PF true D /PB true D /NC 0 D} D
/PW {pop PR} D
/RP {dup () ne {dup dup length 1 sub get 10 ne {(\n) join} if} if
 WR AH SP /CF 0 D 11 0 FS /PF false D} D
/SI {/XO AI LG add NN IN mul BC NN BI mul add D /LL W XO sub D} D
/DT {BN /LG LG 1 sub D SI /LG LG 1 add D BL} D
/DD {BN SI BL} D
/DL {BN XO 0 eq {AH SP} if /LG LG 1 add D BL} D
/LD {BN LG 0 gt {/LG LG 1 sub D} if SI XO 0 eq {AH SP} if BL} D
/UL {BT XO 0 eq {AH SP} {NL} ifelse NR AI NN 0 put /UI UI 1 add D
 /AI AI 1 add D SI BL} D
/LU {BT /UI UI 1 sub D /AI AI 1 sub D SI XO 0 eq {AH SP} {NL} ifelse BL} D
/OL {BT XO 0 eq {AH SP} {NL} ifelse NR AI NN 1 put /AI AI 1 add D SI BL} D
/LO {BT AR AI NN 0 put /AI AI 1 sub D SI XO 0 eq {AH SP} {NL} ifelse BL} D
/LI {BN /BP false D /CI 0 D CP E pop LE neg lt {NP} if NR AI 1 sub NN get 1 eq
 {ON} {0 3 R 2.5 UI 2 mod 0 eq {OB} {B} ifelse 0 -3 R} ifelse BL} D
/BQ {BN AH SP /BC BC 1 add D SI BL} D
/QB {BN AH SP /BC BC 1 sub D SI BL} D
/WB {PF {WR} {BT} ifelse} D
/A  {WB /AF true D} D
/EA {WB /AF false D} D
/CM {WB /IG true D /DE (-->) D} D
/SK {PF {(<) join WR} {BT /IG true D /DE (>) D} ifelse} D
/SS {SZ SL get /SL SL 1 add D} D
/I  {WB SS 4 FS} D
/BD {WB SS 2 FS} D
/TT {WB SS 1 FS} D
/KB {WB SS /CF 0 D 3 FS} D
/CT {WB SS /CF 0 D 4 FS} D
/SM {WB SS /CF 0 D 1 FS} D
/ES {WB /SL SL 1 sub NN D /CF 0 D SZ SL get FR SL get FS} D
/UN {WB /UF true D} D
/NU {WB /UF false D} D

/F 1 D
/BH -35 D
/AH -28 D
/LL W D
/XO 0 D
/YI 0 D
/CI 0 D
/LG 0 D
/AI 0 D
/UI 0 D
/IN 30 D
/BI 12 D
/WW 50 D
/PS 1 D
/AR [0 0 0 0 0 0 0 0 0 0] D
/NR [0 0 0 0 0 0 0 0 0 0] D
/FR [0 0 0 0 0 0 0 0 0 0] D
/SZ [0 0 0 0 0 0 0 0 0 0] D
/HS [19 17 15 13 12 11] D
/HT [2 2 2 2 2 2] D
/SL 0 D
/CF 0 D
/BC 0 D
/MK 7 D
/PN 0 D
/MS (        ) D
/CH 1 string D
/ST 6 string D
/IG false D
/HM false D
/PF false D
/EN false D
/UF false D
/PP false D
/AE false D
/AF false D
/NO false D
/AU true D
/BP true D
%%EndProlog
save
RF 11 SF
0 LE neg 20 sub M
(

)HD(
)TL(More Accessor Methods)LT(
)DH(

)SK(table width=100%>
)SK(tr>
)SK(td align=left>
)A( Previous |  )WB()EA()A( Next |  )WB()EA()A( Trail Map |  )WB()EA()A( Writing Java Programs |  )WB()EA(
)SK(td>
)SK(td align=right>
)A()BD()I(The String and StringBuffer Classes)ES()ES()EA(
)SK(/td>
)SK(/tr>
)SK(/table>
)P(
)SK(hr size=4>

)2 H(
    More Accessor Methods
)EH(
)P(
)BQ(

)4 H(For the String Class)EH(
)BQ(
In addition to the )SM(length\(\))ES( and )SM(charAt\(\))ES(
accessors you saw on the )A(previous page)EA(,
The String class provides two accessors that return the index within the
string of a specific character or string: )SM(indexOf\(\))ES( and
)SM(lastIndexOf\(\))ES(. The )SM(indexOf\(\))ES( method searches
from the beginning of the string forward, and )SM(lastIndexOf\(\))ES(
searches from the end of the string backward.
)P(
The )SM(indexOf\(\))ES( and )SM(lastIndexOf\(\))ES( methods are
frequently used in conjunction with )SM(substring\(\))ES( which returns
a substring of the string.
The following class illustrates the use of )SM(lastIndexOf\(\))ES(
and )SM(substring\(\))ES( to isolate different parts of a filename.)BR(
)BD(NOTE:)ES( these methods don't do any error checking and
assume that their argument contains a full directory path and a filename
with an extension.
)BQ(
)PR(
class Filename {
    String fullpath;
    char pathseparator;

    Filename\(String str, char sep\) {
	fullpath = str;
	pathseparator = sep;
    }

    String extension\(\) {
	int dot = fullpath.lastIndexOf\('.'\);
	return fullpath.substring\(dot + 1\);
    }

    String filename\(\) {
	int dot = fullpath.lastIndexOf\('.'\);
	int sep = fullpath.lastIndexOf\(pathseparator\);
	return fullpath.substring\(sep + 1, dot\);
    }

    String path\(\) {
	int sep = fullpath.lastIndexOf\(pathseparator\);
	return fullpath.substring\(0, sep\);
    }
}
)RP(
)QB(
The )SM(extension\(\))ES( method uses )SM(lastIndexOf\(\))ES( to locate the last
occurrence of the period \('.'\) in the filename.
Then )SM(substring\(\))ES( uses the return value of )SM(lastIndexOf\(\))ES(
to extract the filename extension--that is, the substring from the period \('.'\)
to the end of the string. This code assumes that the filename
actually has a period \('.'\) in it; if the filename does not have a period \('.'\), then
)SM(lastIndexOf\(\))ES( returns -1, and the
)SM(substring\(\))ES( method throws a "string index out of range exception".
)P(
Also, notice that )SM(extension\(\))ES( uses )SM(dot + 1)ES( as the
argument to )SM(substring\(\))ES(. If the period \('.'\)
character is the last character of the string, then )SM(dot + 1)ES( is equal to
the length of the string which is one larger than the largest index into the string
\(because indices start at 0\). However, )SM(substring\(\))ES( accepts an index
equal to \(but not greater than\) the length of the string and interpret
it to mean "the end of the string".
)P(
)BD(Try this:)ES( Inspect the other methods in the Filename class and
notice how the )SM(lastIndexOf\(\))ES( and )SM(substring\(\))ES( methods
work together to isolate different parts of a filename.

)P(
While the methods in the example above uses only one version of the )SM(lastIndexOf\(\))ES(
method, the String class actually supports four different versions of both the
)SM(indexOf\(\))ES( and )SM(lastIndexOf\(\))ES( methods which
)UL(
)LI(
returns the index of the first \(last\) occurrence of the specified character
)LI(
returns the index of the first \(last\) occurrence of the specified character,
searching forward \(backward\) from the specified index
)LI(
returns the index of the first \(last\) occurrence of the specified String.
)LI(
returns the index of the first \(last\) occurrence of the specified String,
searching forward \(backward\) from the specified index
)LU(
)QB(

)4 H(For the StringBuffer Class)EH(
)BQ(
Like String, StringBuffer provides )SM(length\(\))ES( and )SM(charAt\(\))ES(
accessor methods. In addition to these two accessors, StringBuffer also has
a method: )SM(capacity\(\))ES(. The )SM(capacity\(\))ES( method differs
from )SM(length\(\))ES( in that it returns the amount of space currently
allocated for the StringBuffer, rather than the amount of space used.
For example, the capacity of the StringBuffer in the )SM(reverseIt\(\))ES( method
shown here
)BQ(
)PR(
class ReverseString {
    public static String reverseIt\(String source\) {
	int i, len = source.length\(\);
	StringBuffer dest = new StringBuffer\(len\);

	for \(i = \(len - 1\); i >= 0; i--\) {
	    dest.append\(source.charAt\(i\)\);
	}
	return dest.toString\(\);
    }
}
)RP(
)QB(
never changes, while the length of the StringBuffer increases by one for each
iteration of the loop.
)QB(

)QB(
)P(
)SK(hr size=4>
)P(
)SK(table width=100%>
)SK(tr>
)SK(td align=left>
)A( Previous |  )WB()EA()A( Next |  )WB()EA()A( Trail Map |  )WB()EA()A( Writing Java Programs |  )WB()EA(
)SK(td>
)SK(td align=right>
)A()BD()I(The String and StringBuffer Classes)ES()ES()EA(
)SK(/td>
)SK(/tr>
)SK(/table>


)WB showpage restore
