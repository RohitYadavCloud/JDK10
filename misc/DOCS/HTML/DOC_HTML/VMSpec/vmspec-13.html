<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 --> <HTML> <HEAD>
<TITLE>vmspec: Format for the Instructions</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING13></A>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-12.html">Prev</A>       <A HREF="vmspec-14.html">Next</A>       <A HREF="vmspec-12.html">Up</A>       <P>
<HR>
<A NAME=HEADING13-0></A>
<H2>3.1 Format for the Instructions</H2>
Java Virtual Machine instructions are represented in this document by an entry of the following form.<P>
<H3>instruction name</H3>
<I>Short description</I> of the instruction
<TABLE BORDER="1">
<CAPTION>&nbsp;</CAPTION>
<TD>opcode = number<TR>
<TD>operand1<TR>
<TD>operand2<TR>
<TD>...</TABLE>
<P>
<PRE>
Stack: <I>¼., <CODE>value1, value2 </CODE></I>=&gt;<I> ..., <CODE>value3</CODE></I><P>
</PRE>
A <I>longer description</I> that explains the functions of the instruction and indicates any exceptions that might be thrown during execution.<P>
Each line in the syntax diagram represents a single 8-bit byte.<P>
Operations of the Java Virtual Machine most often take their operands from the stack and put their results back on the stack. As a convention, the descriptions do not usually mention when the stack is the source or destination of an operation, but will always mention when it is not. For instance, the <CODE>iload</CODE> instruction has the short description "Load integer from local variable." Implicitly, the integer is loaded onto the stack. The <CODE>iadd</CODE> instruction is described as "Integer add"; both its source and destination are the stack.<P>
Instructions that do not affect the control flow of a computation may be assumed to always advance the virtual machine pc to the opcode of the following instruction. Only instructions that do affect control flow will explicitly mention the effect they have on pc.<P>
<HR>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-12.html">Prev</A>       <A HREF="vmspec-14.html">Next</A>       <A HREF="vmspec-12.html">Up</A>       <P>
</BODY>
</HTML> 