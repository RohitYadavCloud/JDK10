<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 --> <HTML> <HEAD>
<TITLE>vmspec: Attributes</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING11></A>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-10.html">Prev</A>       <A HREF="vmspec-12.html">Next</A>       <A HREF="vmspec-5.html">Up</A>       <P>
<HR>
<A NAME=HEADING11-0></A>
<H2>2.6 <A NAME=MARKER-9-5></A>Attributes</H2>
Attributes are used at several different places in the class format. All attributes have the following format:<P>
<PRE>
<CODE>GenericAttribute_info {</CODE>
<CODE> u2 attribute_name;</CODE>
<CODE> u4 attribute_length;</CODE>
<CODE> u1 info[attribute_length];</CODE>
<CODE>}</CODE>
<CODE></CODE>
</PRE>
The <CODE>attribute_name</CODE> is a 16-bit index into the class's constant pool; the value of <CODE>constant_pool[attribute_name] </CODE>is a <CODE>CONSTANT_Utf8</CODE> string giving the name of the attribute. The field <CODE>attribute_length</CODE> indicates the length of the subsequent information in bytes. This length does not include the six bytes of the <CODE>attribute_name</CODE> and <CODE>attribute_length</CODE>.<P>
In the following text, whenever we allow attributes, we give the name of the attributes that are currently understood. In the future, more attributes will be added. Class file readers are expected to skip over and ignore the information in any attribute they do not understand.<P>
<H3>SourceFile</H3>
The "SourceFile" attribute has the following format:<P>
<PRE>
<CODE>SourceFile_attribute {</CODE>
<CODE> u2 attribute_name_index;</CODE>
<CODE> u4 attribute_length;</CODE>
<CODE> u2 sourcefile_index;</CODE>
<CODE>}</CODE>
</PRE>
<H3>attribute_name_index</H3>
<CODE> constant_pool[attribute_name_index]</CODE> is the <CODE>CONSTANT_Utf8</CODE> string <CODE>&quot;SourceFile</CODE>&quot;.<P>
<H3>attribute_length</H3>
The length of a SourceFile_attribute must be 2.<P>
<H3>sourcefile_index</H3>
<CODE>constant_pool[sourcefile_index]</CODE> is a <CODE>CONSTANT_Utf8</CODE> string giving the source file from which this class file was compiled.<P>
<H3>ConstantValue</H3>
The "ConstantValue" attribute has the following format:<P>
<PRE>
<CODE>ConstantValue_attribute {</CODE>
<CODE> u2 attribute_name_index;</CODE>
<CODE> u4 attribute_length;</CODE>
<CODE> u2 constantvalue_index;</CODE>
<CODE>}</CODE>
</PRE>
<H3>attribute_name_index</H3>
<CODE> constant_pool[attribute_name_index]</CODE> is the <CODE>CONSTANT_Utf8</CODE> string &quot;<CODE>ConstantValue</CODE>&quot;.<P>
<H3>attribute_length</H3>
The length of a ConstantValue_attribute must be 2.<P>
<H3>constantvalue_index</H3>
<CODE>constant_pool[constantvalue_index]</CODE>gives the constant value for this field. <P>
The constant pool entry must be of a type appropriate to the field, as shown by the following table:
<TABLE BORDER="1"><TD>long<TD><CODE>CONSTANT_Long</CODE><TR>
<TD>float<TD><CODE>CONSTANT_Float</CODE><TR>
<TD>double<TD><CODE>CONSTANT_Double</CODE><TR>
<TD>int, short, char, byte, boolean<TD><CODE>CONSTANT_Integer</CODE></TABLE>
<P>
<H3>Code</H3>
The "Code" attribute has the following format:<P>
<PRE>
<CODE>Code_attribute {</CODE>
<CODE> u2 attribute_name_index;</CODE>
<CODE> u4 attribute_length;</CODE>
<CODE> u2 max_stack;</CODE>
<CODE> u2 max_locals;</CODE>
<CODE> u4 code_length;</CODE>
<CODE> u1 code[code_length];</CODE>
<CODE> u2 exception_table_length;</CODE>
<CODE> {  u2    start_pc;</CODE>
<CODE>    u2    end_pc;</CODE>
<CODE>    u2    handler_pc;</CODE>
<CODE>    u2    catch_type;</CODE>
<CODE> }  exception_table[exception_table_length];</CODE>
<CODE> u2 attributes_count;</CODE>
<CODE> attribute_info attributes[attribute_count];</CODE>
<CODE></CODE>
<CODE>}</CODE>
</PRE>
<H3>attribute_name_index</H3>
<CODE> constant_pool[attribute_name_index]</CODE> is the <CODE>CONSTANT_Utf8</CODE> string &quot;<CODE>Code</CODE>&quot;.<P>
<H3>attribute_length</H3>
This field indicates the total length of the "Code" attribute, excluding the initial six bytes.<P>
<H3>max_stack</H3>
Maximum number of entries on the operand stack that will be used during execution of this method. See the other chapters in this spec for more information on the operand stack.<P>
<H3>max_locals</H3>
Number of local variable slots used by this method. See the other chapters in this spec for more information on the local variables.<P>
<H3>code_length</H3>
The number of bytes in the virtual machine code for this method.<P>
<H3>code</H3>
These are the actual bytes of the virtual machine code that implement the method. When read into memory, if the first byte of code is aligned onto a multiple-of-four boundary the the <CODE>tableswitch</CODE> and <CODE>tablelookup</CODE> opcode entries will be aligned; see their description for more information on alignment requirements.<P>
<H3>exception_table_length</H3>
The number of entries in the following exception table.<P>
<H3>exception_table</H3>
Each entry in the exception table describes one exception handler in the code. <P>
<H3>start_pc, end_pc</H3>
The two fields <CODE>start_pc</CODE> and <CODE>end_pc</CODE> indicate the ranges in the code at which the exception handler is active. The values of both fields are offsets from the start of the code. <CODE>start_pc</CODE> is inclusive. <CODE>end_pc</CODE> is exclusive.<P>
<H3>handler_pc</H3>
This field indicates the starting address of the exception handler. The value of the field is an offset from the start of the code.<P>
<H3>catch_type</H3>
If <CODE>catch_type</CODE> is nonzero, then <CODE>constant_pool[catch_type]</CODE> will be the class of exceptions that this exception handler is designated to catch. This exception handler should only be called if the thrown exception is an instance of the given class.<P>
If catch_type is zero, this exception handler should be called for all exceptions.<P>
<H3>attributes_count</H3>
This field indicates the number of additional attributes about code. The "Code" attribute can itself have attributes. <P>
<H3>attributes</H3>
A "Code" attribute can have any number of optional attributes associated with it. Each attribute has a name, and other additional information. Currently, the only code attributes defined are the "LineNumberTable" and "LocalVariableTable," both of which contain debugging information.<P>
<H3>Exceptions Table</H3>
This table is used by compilers which indicate which Exceptions a method is declared to throw:<P>
<PRE>
<CODE>Exceptions_attribute {</CODE>
<CODE> u2 attribute_name_index;</CODE>
<CODE> u4 attribute_length;</CODE>
<CODE> u2 number_of_exceptions;</CODE>
<CODE> u2 exception_index_table[number_of_exceptions];</CODE>
<CODE>}</CODE>
</PRE>
<H3>attribute_name_index</H3>
<CODE> constant_pool[attribute_name_index]</CODE> will be the <CODE>CONSTANT_Utf8</CODE> string &quot;<CODE>Exceptions</CODE>&quot;.<P>
<H3>attribute_length</H3>
This field indicates the total length of the Exceptions_attribute, excluding the initial six bytes.<P>
<H3>number_of_exceptions</H3>
This field indicates the number of entries in the following exception index table.<P>
<H3>exception_index_table</H3>
Each value in this table is an index into the constant pool. For each table element (<CODE>exception_index_table[i]</CODE> != 0, where 0 &lt;=<CODE> i</CODE> &lt; <CODE>number_of_exceptions</CODE>), then <CODE>constant_pool[exception_index+table[i]]</CODE> is a Exception that this class is declared to throw.<P>
<H3>LineNumberTable</H3>
This attribute is used by debuggers and the exception handler to determine which part of the virtual machine code corresponds to a given location in the source. The LineNumberTable_attribute has the following format:<P>
<PRE>
<CODE>LineNumberTable_attribute {</CODE>
<CODE> u2  attribute_name_index;</CODE>
<CODE> u4  attribute_length;</CODE>
<CODE> u2  line_number_table_length;</CODE>
<CODE> {  u2       start_pc;    </CODE>
<CODE>  u2    line_number;</CODE>
<CODE> }  line_number_table[line_number_table_length];</CODE>
<CODE>}</CODE>
</PRE>
<H3>attribute_name_index</H3>
<CODE> constant_pool[attribute_name_index]</CODE> will be the <CODE>CONSTANT_Utf8</CODE> string &quot;<CODE>LineNumberTable</CODE>&quot;.<P>
<H3>attribute_length</H3>
This field indicates the total length of the LineNumberTable_attribute, excluding the initial six bytes.<P>
<H3>line_number_table_length</H3>
This field indicates the number of entries in the following line number table.<P>
<H3>line_number_table</H3>
Each entry in the line number table indicates that the line number in the source file changes at a given point in the code.<P>
<H3>start_pc</H3>
This field indicates the place in the code at which the code for a new line in the source begins. <CODE>source_p</CODE>c &lt;&lt;SHOULD THAT BE <CODE>start_pc</CODE>?&gt;&gt; is an offset from the beginning of the code.<P>
<H3>line_number</H3>
The line number that begins at the given location in the file.<P>
<H3>LocalVariableTable</H3>
This attribute is used by debuggers to determine the value of a given local variable during the dynamic execution of a method. The format of the LocalVariableTable_attribute is as follows:<P>
<PRE>
<CODE>LocalVariableTable_attribute {</CODE>
<CODE> u2 attribute_name_index;</CODE>
<CODE> u4 attribute_length;</CODE>
<CODE> u2 local_variable_table_length;</CODE>
<CODE> {  u2     start_pc;</CODE>
<CODE>    u2    length;</CODE>
<CODE>    u2    name_index;</CODE>
<CODE>    u2    signature_index;</CODE>
<CODE>    u2    slot;</CODE>
<CODE> }  local_variable_table[local_variable_table_length];</CODE>
<CODE>} </CODE>
</PRE>
<H3>attribute_name_index</H3>
<CODE> constant_pool[attribute_name_index]</CODE> will be the <CODE>CONSTANT_Utf8</CODE> string &quot;<CODE>LocalVariableTable</CODE>&quot;.<P>
<H3>attribute_length</H3>
This field indicates the total length of the LineNumberTable_attribute, excluding the initial six bytes.<P>
<H3>local_variable_table_length</H3>
This field indicates the number of entries in the following local variable table.<P>
<H3>local_variable_table</H3>
Each entry in the local variable table indicates a code range during which a local variable has a value. It also indicates where on the stack the value of that variable can be found.<P>
<H3>start_pc, length</H3>
The given local variable will have a value at the code between <CODE>start_pc</CODE> and <CODE>start_pc</CODE> + <CODE>length</CODE>. The two values are both offsets from the beginning of the code.<P>
<H3>name_index, signature_index</H3>
 <CODE>constant_pool[name_index]</CODE>and<CODE> constant_pool[signature_index] </CODE>are <CODE>CONSTANT_Utf8</CODE> strings giving the name and signature of the local variable. <P>
<H3>slot</H3>
The given variable will be the slot<EM>th </EM>local variable in the method's frame.<P>
<PRE>
<CODE></CODE>
</PRE>
<HR>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-10.html">Prev</A>       <A HREF="vmspec-12.html">Next</A>       <A HREF="vmspec-5.html">Up</A>       <P>
</BODY>
</HTML> 