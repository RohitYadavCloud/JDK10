<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 --> <HTML> <HEAD>
<TITLE>vmspec: Java Virtual Machine Architecture</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING4></A>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-3.html">Prev</A>       <A HREF="vmspec-5.html">Next</A>              <P>
<HR>
<A NAME=HEADING4-0></A>
<H1>1	 Java Virtual Machine Architecture</H1>
<DL>
<DT><A HREF="vmspec-4.html#HEADING4-0"><B>1.1	</B> - Supported Data Types</A><DD>
<DT><A HREF="vmspec-4.html#HEADING4-12"><B>1.2	</B> - Registers</A><DD>
<DT><A HREF="vmspec-4.html#HEADING4-20"><B>1.3	</B> - Local Variables</A><DD>
<DT><A HREF="vmspec-4.html#HEADING4-24"><B>1.4	</B> - The Operand Stack </A><DD>
<DT><A HREF="vmspec-4.html#HEADING4-36"><B>1.5	</B> - Execution Environment</A><DD>
<DT><A HREF="vmspec-4.html#HEADING4-57"><B>1.6	</B> - Garbage Collected Heap</A><DD>
<DT><A HREF="vmspec-4.html#HEADING4-59"><B>1.7	</B> - Method Area</A><DD>
<DT><A HREF="vmspec-4.html#HEADING4-61"><B>1.8	</B> - The Java Instruction Set</A><DD>
<DT><A HREF="vmspec-4.html#HEADING4-69"><B>1.9	</B> - Limitations</A><DD>
</DL>

<A NAME=HEADING4-1></A>
<HR>
<H2>1.1 Supported Data Types</H2>
The virtual machine data types include the basic data types of the Java language:<P>
<PRE>
<CODE>byte  // 1-byte signed 2's complement integer
short  // 2-byte signed 2's complement integer
int  // 4-byte signed 2's complement integer
long  // 8-byte signed 2's complement integer
float  // 4-byte IEEE 754 single-precision float
double  // 8-byte IEEE 754 double-precision float
char  // 2-byte unsigned Unicode character</CODE>
</PRE>
Nearly all Java type checking is done at compile time. Data of the primitive types shown above need not be tagged by the hardware to allow execution of Java. Instead, the bytecodes that operate on primitive values indicate the types of the operands so that, for example, the <CODE>iadd</CODE>, <CODE>ladd</CODE>, <CODE>fadd</CODE>, and <CODE>dadd</CODE> instructions each add two numbers, whose types are <CODE>int</CODE>, <CODE>long</CODE>, <CODE>float</CODE>, and <CODE>double</CODE>, respectively<P>
The virtual machine doesn't have separate instructions for <CODE>boolean</CODE> types. Intead, integer instructions, including integer returns, are used to operate on <CODE>boolean</CODE> values; <CODE>byte</CODE> arrays are used for arrays of <CODE>boolean</CODE>.<P>
The virtual machine specifies that floating point be done in IEEE 754 format, with support for gradual underflow. Older computer architectures that do not have support for IEEE format may run Java numeric programs very slowly.<P>
Other virtual machine data types include:<P>
<PRE>
<CODE>object  // 4-byte reference to a Java object
returnAddress  // 4 bytes, used with jsr/ret/jsr_w/ret_w instructions</CODE>
</PRE>
<STRONG>Note:</STRONG> Java arrays are treated as objects.<STRONG></STRONG><P>
This specification does not require any particular internal structure for objects. In our implementation an object reference is to a handle, which is a pair of pointers: one to a method table for the object, and the other to the data allocated for the object. Other implementations may use inline caching, rather than method table dispatch; such methods are likely to be faster on hardware that is emerging between now and the year 2000.<P>
Programs represented by Java Virtual Machine bytecodes are expected to maintain proper type discipline and an implementation may refuse to execute a bytecode program that appears to violate such type discipline.<P>
While the Java Virtual Machines would appear to be limited by the bytecode definition to running on a 32-bit address space machine, it is possible to build a version of the Java Virtual Machine that automatically translates the bytecodes into a 64-bit form. A description of this transformation is beyond the scope of this specification.<P>
<A NAME=HEADING4-13></A>
<HR>
<H2>1.2 Registers</H2>
At any point the virtual machine is executing the code of a single method, and the <CODE>pc</CODE> register contains the address of the next bytecode to be executed.<P>
Each method has memory space allocated for it to hold:<P>
<UL>
<LI>a set of local variables, referenced by a <CODE>vars</CODE> register, <P>
<LI>an operand stack, referenced by an <CODE>optop</CODE> register, and<P>
<LI>a execution environment structure, referenced by a <CODE>frame</CODE> register.<P>
</UL>
All of this space can be allocated at once, since the size of the local variables and operand stack are known at compile time, and the size of the execution environment structure is well-known to the interpreter.<P>
All of these registers are 32 bits wide.<P>
<A NAME=HEADING4-21></A>
<HR>
<H2>1.3 Local Variables</H2>
Each Java method uses a fixed-sized set of local variables. They are addressed as word offsets from the <CODE>vars</CODE> register. Local variables are all 32 bits wide. <P>
Long integers and double precision floats are considered to take up two local variables but are addressed by the index of the first local variable. (For example, a local variable with index <I>n</I> containing a double precision float actually occupies storage at indices <I>n</I> and <I>n</I>+1.) The virtual machine specification does not require 64-bit values in local variables to be 64-bit aligned. Implementors are free to decide the appropriate way to divide long integers and double precision floats into two words.<P>
Instructions are provided to load the values of local variables onto the operand stack and store values from the operand stack into local variables.<P>
<A NAME=HEADING4-25></A>
<HR>
<H2>1.4 The Operand Stack </H2>
The machine instructions all take operands from an operand stack, operate on them, and return results to the stack. We chose a stack organization so that it would be easy to emulate the machine efficiently on machines with few or irregular registers such as the Intel 486.<P>
The operand stack is 32 bits wide. It is used to pass parameters to methods and receive method results, as well as to supply parameters for operations and save operation results.<P>
For example, the <CODE>iadd</CODE> instruction adds two integers together. It expects that the integers to be added are the top two words on the operand stack, pushed there by previous instructions. Both integers are popped from the stack, added, and their sum pushed back onto the operand stack. Subcomputations may be nested on the operand stack, and result in a single operand that can be used by the nesting computation. <P>
Each primitive data type has specialized instructions that know how to operate on operands of that type. Each operand requires a single location on the stack, except for <CODE>long</CODE> and <CODE>double</CODE>, which require two locations.<P>
Operands must be operated on by operators appropriate to their type. It is illegal, for example, to push two <CODE>int</CODE>s and then treat them as a <CODE>long</CODE>. This restriction is enforced, in the Sun implementation, by the bytecode verifier. However, a small number of operations (the <CODE>dup</CODE> opcodes and <CODE>swap</CODE>) operate on runtime data areas as raw values of a given width without regard to type.<P>
In our description of the virtual machine instructions below, the effect of an instruction's execution on the operand stack is represented textually, with the stack growing from left to right, and each 32-bit word separately represented. Thus:<P>
<PRE>
Stack: <I>..., <CODE>value1, value2 =&gt; ..., value3</CODE></I><P>
</PRE>
shows an operation that begins by having <I>value2</I> on top of the stack with <I>value1</I> just beneath it. As a result of the execution of the instruction, <I>value1</I> and <I>value2</I> are popped from the stack and replaced by <I>value3</I>, which has been calculated by the instruction. The remainder of the stack, represented by an ellipsis, is unaffected by the instruction's execution.<P>
The types <CODE>long</CODE> and <CODE>double</CODE> take two 32-bit words on the operand stack:<P>
<PRE>
Stack: <I>... =&gt; ...,<CODE> value-word1, value-word2</CODE></I><P>
</PRE>
This specification does not say how the two words are selected from the 64-bit <CODE>long</CODE> or <CODE>double</CODE> value; it is only necessary that a particular implementation be internally consistent.<P>
<A NAME=HEADING4-37></A>
<HR>
<H2>1.5 Execution Environment</H2>
The information contained in the execution environment is used to do dynamic linking, normal method returns, and exception propagation.<P>
<H3>Dynamic Linking</H3>
The execution environment contains references to the interpreter symbol table for the current method and current class, in support of dynamic linking of the method code. The class file code for a method refers to methods to be called and variables to be accessed symbolically. Dynamic linking translates these symbolic method calls into actual method calls, loading classes as necessary to resolve as-yet-undefined symbols, and translates variable accesses into appropriate offsets in storage structures associated with the runtime location of these variables.<P>
This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.<P>
<H3>Normal Method Returns</H3>
If execution of the current method completes normally, then a value is returned to the calling method. This occurs when the calling method executes a return instruction appropriate to the return type.<P>
The execution environment is used in this case to restore the registers of the caller, with the program counter of the caller appropriately incremented to skip the method call instruction. Execution then continues in the calling method's execution environment.<P>
<H3>Exception and Error Propagation</H3>
An exceptional condition, known in Java as an <CODE>Error</CODE> or <CODE>Exception</CODE>, which are subclasses of <CODE>Throwable</CODE>, may arise in a program because of:<P>
<UL>
<LI>a dynamic linkage failure, such as a failure to find a needed class file,<P>
<LI>a run-time error, such as a reference through a null pointer,<P>
<LI>an asynchronous event, such as is thrown by <CODE>Thread.stop</CODE>, from another thread,<P>
<LI>the program using a <CODE>throw</CODE> statement.<P>
</UL>
When an exception occurs:<P>
<UL>
<LI>A list of catch clauses associated with the current method is examined. Each <CODE>catch</CODE> clause describes the instruction range for which it is active, describes the type of exception that it is to handle, and has the address of the code to handle it.<P>
<LI>An exception matches a <CODE>catch</CODE> clause if the instruction that caused the exception is in the appropriate instruction range, and the exception type is a subtype of the type of exception that the <CODE>catch</CODE> clause handles. If a matching <CODE>catch</CODE> clause is found, the system branches to the specified handler. If no handler is found, the process is repeated until all the nested catch clauses of the current method have been exhausted.<P>
<LI>The order of the <CODE>catch</CODE> clauses in the list is important. The virtual machine execution continues at the first matching catch clause. Because Java code is structured, it is always possible to sort all the exception handlers for one method into a single list that, for any possible program counter value, can be searched in linear order to find the proper (innermost containing applicable) exception handler for an exception occuring at that program counter value.<P>
<LI>If there is no matching <CODE>catch</CODE> clause then the current method is said to have as its outcome the uncaught exception. The execution state of the method that called this method is restored from the execution environment, and the propagation of the exception continues, as though the exception had just occurred in this caller.<P>
</UL>
<H3>Additional Information</H3>
The execution environment may be extended with additional implementation-specific information, such as debugging information.<P>
<A NAME=HEADING4-58></A>
<HR>
<H2>1.6 Garbage Collected Heap</H2>
The Java heap is the runtime data area from which class instances (objects) are allocated. The Java language is designed to be garbage collected -- it does not give the programmer the ability to deallocate objects explicitly. Java does not presuppose any particular kind of garbage collection; various algorithms may be used depending on system requirements.<P>
<A NAME=HEADING4-60></A>
<HR>
<H2>1.7 Method Area</H2>
The method area is analogous to the store for compiled code in conventional languages or the text segment in a UNIX process. It stores method code (compiled Java code) and symbol tables. In the current Java implementation, method code is not part of the garbage-collected heap, although this is planned for a future release.<P>
<A NAME=HEADING4-62></A>
<HR>
<H2>1.8 The Java Instruction Set</H2>
An instruction in the Java instruction set consists of a one-byte <I>opcode</I> specifying the operation to be performed, and zero or more <I>operands </I>supplying parameters or data that will be used by the operation. Many instructions have no operands and consist only of an opcode.<P>
The inner loop of the virtual machine execution is effectively:<P>
<PRE>
<CODE>do {
    fetch an opcode byte
    execute an action depending on the value of the opcode
} while (there is more to do);</CODE>
</PRE>
The number and size of the additional operands is determined by the opcode. If an additional operand is more than one byte in size, then it is stored in <EM>big-endian</EM> order -- high order byte first. For example, a 16-bit parameter is stored as two bytes whose value is: <P>
<PRE>
<CODE>first_byte * 256 + second_byte</CODE>
</PRE>
The bytecode instruction stream is only byte-aligned, with the exception being the <CODE>tableswitch</CODE> and <CODE>lookupswitch</CODE> instructions, which force alignment to a 4-byte boundary within their instructions.<P>
These decisions keep the virtual machine code for a compiled Java program compact and reflect a conscious bias in favor of compactness at some possible cost in performance.<P>
<A NAME=HEADING4-70></A>
<HR>
<H2>1.9 Limitations</H2>
The per-class constant pool has a maximum of 65535 entries. This acts as an internal limit on the total complexity of a single class.<P>
The amount of code per method is limited to 65535 bytes by the sizes of the indices in the code in the exception table, the line number table, and the local variable table. This may be fixed for 1.0beta2.<P>
Besides this limit, the only other limitation of note is that the number of words of arguments in a method call is limited to 255.<P>
<HR>
<A HREF="vmspec-1.html">Contents</A>       <A HREF="vmspec-3.html">Prev</A>       <A HREF="vmspec-5.html">Next</A>              <P>
</BODY>
</HTML> 