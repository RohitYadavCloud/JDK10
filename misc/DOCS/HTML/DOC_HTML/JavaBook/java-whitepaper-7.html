<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 --> <HTML> <HEAD>
<TITLE>The Java(tm) White Paper: Interpreted and Dynamic</TITLE>
</HEAD>
<BODY>
<A NAME=HEADING7></A>
<A HREF="java-whitepaper-8.html">Next</A>       <A HREF="java-whitepaper-6.html">Prev</A>              <A HREF="java-whitepaper-1.html">Contents</A><P>
<HR>
<H1>Interpreted and Dynamic</H1>
<DL>
<DT><A HREF="java-whitepaper-7.html#HEADING7-7"><B>	5.1	</B> - Dynamic Loading and Binding</A><DD>
<DT><A HREF="java-whitepaper-7.html#HEADING7-21"><B>	5.2	</B> - Summary</A><DD>
</DL>

<HR>
<A NAME=HEADING7-0></A>


Programmers using "traditional" software development tools have become resigned to the artificial edit-compile-link-load-throw-the-application-off-the-cliff-let-it-crash-and-start-all-over-again style of current development practice.<P>
Additionally, keeping track of what must be recompiled when a declaration changes somewhere else strains the capabilities of development tools--even fancy "make"-style tools such as found on UNIX systems. This development approach bogs down as the code bases of applications grow to hundreds of thousands of lines.<P>
Better methods of fast and fearless prototyping and development are needed. The Java language environment is one of those better ways, because it's <I>interpreted</I> and <I>dynamic</I>.<P>
As discussed in the previous chapter on architecture-neutrality, the Java compiler generates byte codes for the Java Virtual Machine<A HREF="#FOOTNOTE-3">[3]</A>, which was introduced briefly in <A HREF=java-whitepaper-6.html#MARKER-9-1>Chapter 4</A>. The notion of a virtual interpreted machine is not new. But the Java language brings the concepts into the realm of secure, distributed, network-based systems.<P>
The Java language virtual machine is a strictly defined virtual machine for which an interpreter must be available for each hardware architecture and operating system on which you wish to run Java language applications. Once you have the Java language interpreter and run-time support available on a given hardware and operating system platform, you can run any Java language application from anywhere, always assuming the specific Java language application is written in a portable manner.<P>
The notion of a separate "link" phase after compilation is pretty well absent from the Java environment. Linking, which is actually the process of loading new classes by the <I>Class Loader</I>, is a more incremental and lightweight process. The concomitant speedup in your development cycle means that your development process can be much more rapid and exploratory, and because of the robust nature of the Java language and run-time system, you will catch bugs at a much earlier phase of the cycle.<P>
<A NAME=HEADING7-8></A>
<HR>
<H2> 5.1 Dynamic Loading and Binding</H2>
The Java language's portable and interpreted nature produces a highly dynamic and <I>dynamically-extensible</I> system. The Java language was designed to adapt to evolving environments. Classes are linked in as required and can be downloaded from across networks. Incoming code is verified before being passed to the interpreter for execution. <P>
Object-oriented programming has become accepted as a means to solve at least a part of the "software crisis", by assisting encapsulation of data and corresponding procedures, and encouraging reuse of code. Most programmers doing object-oriented development today have adopted C++ as their language of choice. But C++ suffers from a serious problem that impedes its widespread use in the production and distribution of "software ICs". This defect is known as the <I>fragile superclass problem</I>.<P>
<H3> 5.1.1 The Fragile Superclass Problem</H3>
This problem arises as a side-effect of the way that C++ is usually implemented. Any time you add a new method or a new instance variable to a class, any and all classes that reference that class will require a recompilation, or they'll break. Keeping track of the dependencies between class definitions and their clients has proved to be a fruitful source of programming error in C++, even with the help of "make"-like utilities.The fragile superclass issue is sometimes also referred to as the "constant recompilation problem." You <I>can</I> avoid these problems in C++, but with extraordinary difficulty, and doing so effectively means not using any of the language's object-oriented features directly. By avoiding the object-oriented features of C++, developers defeat the goal of re-usable "software ICs".<P>
<H3> 5.1.2 Solving the Fragile Superclass Problem</H3>
The Java language solves the fragile superclass problem in several stages. The Java compiler doesn't compile references down to numeric values--instead, it passes symbolic reference information through to the byte code verifier and the interpreter. The Java interpreter performs final name resolution once, when classes are being linked. Once the name is resolved, the reference is rewritten as a numeric offset, enabling the Java interpreter to run at full speed.<P>
Finally, the storage layout of objects is not determined by the compiler. The layout of objects in memory is deferred to run time and determined by the interpreter. Updated classes with new instance variables or methods can be linked in without affecting existing code.<P>
At the small expense of a name lookup the first time any name is encountered, the Java language eliminates the fragile superclass problem. Java programmers can use object-oriented programming techniques in a much more straightforward fashion without the constant recompilation burden engendered by C++. Libraries can freely add new methods and instance variables without any effect on their clients. Your life as a programmer is simpler.<P>
<H3> 5.1.3 Java Language Interfaces</H3>
An <I>interface</I> in the Java language is simply a specification of methods that an object implements. The concept of an interface in the Java language was borrowed from the Objective-C concept of a <I>protocol</I>. An interface does not include instance variables or implementation code. You can import and use multiple interfaces in a flexible manner, providing the benefits of multiple inheritance without the inherent difficulties created by the usual rigid class inheritance structure.<P>
<H3> 5.1.4 Run-Time Representations</H3>
Classes in the Java language have a run-time representation. There is a class named <CODE>Class</CODE>, instances of which contain run-time class definitions. If you're handed an object, you can find out what class it belongs to. In a C or C++ program, you may be handed a pointer to an object, but if you don't know what type of object it is, you have no way to find out. In the Java language, finding out based on the run-time type information is straightforward. <P>
It is also possible to look up the definition of a class given a string containing its name. This means that you can compute a data type name and easily have it dynamically-linked into the running system.<P>
<A NAME=HEADING7-22></A>
<HR>
<H2> 5.2 Summary</H2>
The interpreted and dynamic nature of Java provides several benefits:<P>
<UL>
<LI>The interpreted environment enables fast prototyping without waiting for the traditional compile and link cycle,<P>
<LI>The environment is dynamically extensible, whereby classes are loaded on the fly as required,<P>
<LI>The fragile superclass problem that plagues C++ developers is eliminated because of deferral of memory layout decisions to run time.<P>
</UL>
<HR>

<A NAME="FOOTNOTE-3">[3] One of the ancestors of the virtual machine concept was the UCSD P System, developed by Kenneth Bowles at the University of California at San Diego in the late 1970s.
<HR>
<A HREF="java-whitepaper-8.html">Next</A>       <A HREF="java-whitepaper-6.html">Prev</A>              <A HREF="java-whitepaper-1.html">Contents</A><P>
<B>The Java(tm) Language Environment: A White Paper</B><P>
</BODY>
</HTML> 